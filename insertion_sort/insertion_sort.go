package insertion_sort

/*
Сортировка вставками (Insertion Sort) — это алгоритм сортировки, который постепенно строит
отсортированную часть массива, добавляя по одному элементу из неотсортированной части.
Алгоритм имитирует процесс сортировки карт в руке: берём новую карту и вставляем её в
правильное место среди уже отсортированных карт.

Алгоритм:
1) Делим массив на две части:
  - Слева — отсортированная часть (изначально содержит только первый элемент).
  - Справа — неотсортированная часть (все остальные элементы).
    2. На каждой итерации берём первый элемент из неотсортированной части и вставляем его в
    отсортированную часть, сдвигая вправо элементы, которые больше вставляемого.
    3. После вставки элемента граница между отсортированной и неотсортированной частями
    сдвигается вправо на 1.
    4. На каждой итерации отсортированная часть увеличивается на 1 элемент, а неотсортированная
    уменьшается, пока весь массив не станет отсортированным.

Характеристики алгоритма:
- Устойчивость: Да, алгоритм устойчив, так как сохраняет относительный порядок равных элементов.
- Временная сложность:
  - Лучший случай: O(n) — массив уже отсортирован, требуется только n-1 сравнений без сдвигов.
  - Средний случай: O(n²) — в среднем требуется сравнение и сдвиг элементов для каждой пары,
    что приводит к квадратичной зависимости от длины массива.
  - Худший случай: O(n²) — массив отсортирован в обратном порядке, и для каждого элемента
    из неотсортированной части нужно сдвинуть все элементы отсортированной части вправо.
  - Подробно:
  - Внешний цикл выполняется n-1 раз (от 1 до len(arr)-1).
  - Внутренний цикл в худшем случае выполняет до i операций (сравнений и обменов), где i —
    текущий индекс внешнего цикла. Сумма операций: 1 + 2 + ... + (n-1) = n(n-1)/2, что даёт O(n²).

- Пространственная сложность:
  - O(1) — алгоритм является "in-place" (сортировка на месте), использует только несколько
    дополнительных переменных (i, j), независимо от размера входного массива. Никакой
    дополнительной памяти под структуры данных не выделяется.

- Преимущества:
  - Эффективен для небольших массивов (n < 50).
  - Хорошо работает с частично отсортированными данными (адаптивность).
  - Прост в реализации.

- Недостатки:
  - Неэффективен для больших массивов из-за O(n²) в среднем и в худшем случае.
*/

func InsertionSort(arr []int) {
	for i := 1; i < len(arr); i++ {
		j := i

		for j > 0 {
			if arr[j-1] > arr[j] {
				arr[j-1], arr[j] = arr[j], arr[j-1]
			}
			j--
		}
	}
}
