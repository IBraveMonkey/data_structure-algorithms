package quick_sort

/*
Quick Sort (Быстрая сортировка)

Что это такое?
Quick Sort — это эффективный алгоритм сортировки, работающий по принципу "Разделяй и властвуй". Он выбирает опорный элемент (pivot) и переупорядочивает массив так, что все элементы меньше pivot оказываются слева, а больше — справа. Затем рекурсивно сортирует эти две части.

Зачем это нужно?
- Сортировать массивы максимально быстро в среднем случае.
- Стандарт де-факто для сортировок in-place (без использования большого количества доп. памяти, если реализован правильно).

В чём смысл?
- Разбиение (Partitioning) — ключевой этап. Мы "раскидываем" элементы относительно pivot.
- После разбиения pivot находится на своем "законном" месте в отсортированном массиве.

Когда использовать?
- Когда нужна быстрая сортировка общего назначения (как в стандартных библиотеках).
- Когда важна скорость в среднем случае O(n log n).
- Когда не требуется устойчивость (стабильность) сортировки (порядок равных элементов может меняться).

Как работает?
1. Выбираем pivot (первый, последний, средний или медиану трех).
2. Проходим по массиву и перемещаем элементы: меньшие pivot -> влево, большие -> вправо.
3. Рекурсивно запускаем Quick Sort для левой и правой подчастей.

Сложность:
- Время: O(n log n) в среднем. O(n^2) в худшем случае (если pivot выбирается неудачно, например, всегда минимум/максимум).
- Память: O(log n) для стека вызовов (в in-place версиях) или O(n) в наивных реализациях с созданием новых массивов.
*/

func medianOfThree(arr []int, low, high int) int {
	mid := low + (high-low)/2

	// Сравнение трех элементов: первый, средний, последний для выбора медианы
	if arr[low] > arr[mid] {
		arr[low], arr[mid] = arr[mid], arr[low]
	}
	if arr[low] > arr[high] {
		arr[low], arr[high] = arr[high], arr[low]
	}
	if arr[mid] > arr[high] {
		arr[mid], arr[high] = arr[high], arr[mid]
	}

	return mid
}

// QuickSort - реализация сортировки.
// Примечание: данная реализация создает новые слайсы (не in-place) для простоты понимания.
// Для production-кода обычно используется in-place версия с partition function.
func QuickSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}

	pivotIndex := medianOfThree(arr, 0, len(arr)-1)
	pivot := arr[pivotIndex]

	left := make([]int, 0, len(arr)/2)
	right := make([]int, 0, len(arr)/2)
	pivots := make([]int, 0) // Для обработки дубликатов pivot-а

	for _, v := range arr {
		if v < pivot {
			left = append(left, v)
		} else if v > pivot {
			right = append(right, v)
		} else {
			pivots = append(pivots, v)
		}
	}

	return append(append(QuickSort(left), pivots...), QuickSort(right)...)
}
