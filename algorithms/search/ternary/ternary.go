package ternary

/*
Ternary Search (Тернарный поиск)

Что это такое?
Похож на бинарный поиск, но делит массив не на 2, а на 3 части с помощью двух точек m1 и m2.

Зачем это нужно?
- В основном используется для поиска экстремума (минимума или максимума) в УНИМОДАЛЬНЫХ функциях (функциях, которые сначала возрастают, потом убывают, или наоборот).
- Для поиска в отсортированном массиве обычно хуже бинарного (больше сравнений), поэтому используется реже.

В чём смысл?
- Мы отбрасываем 1/3 области поиска на каждом шаге.

Когда использовать?
- Поиск пика функции f(x) (например, параблы).
- Если нужно найти элемент в отсортированном массиве (но Binary Search лучше).

Как работает (для функции):
1. m1 = left + (right-left)/3
2. m2 = right - (right-left)/3
3. Если f(m1) < f(m2) (и ищем максимум), то максимум точно не в первой трети -> left = m1.
4. Иначе -> right = m2.

Как работает (для массива):
1. Сравниваем target с arr[m1] и arr[m2].
2. Если совпало - нашли.
3. Если меньше arr[m1] -> идем в левую треть.
4. Если больше arr[m2] -> идем в правую треть.
5. Иначе -> идем в среднюю треть.

Сложность:
- O(log3 n), что эквивалентно O(log n). (Основание логарифма не влияет на асимптотику).
*/

// TernarySearchIterative - поиск элемента в отсортированном массиве
func TernarySearch(data []int, target int) int {
	left := 0
	right := len(data) - 1

	for left <= right {
		m1 := left + (right-left)/3
		m2 := right - (right-left)/3

		if data[m1] == target {
			return m1
		}
		if data[m2] == target {
			return m2
		}

		if target < data[m1] {
			right = m1 - 1 // Левая треть
		} else if target > data[m2] {
			left = m2 + 1 // Правая треть
		} else {
			left = m1 + 1 // Средняя треть
			right = m2 - 1
		}
	}

	return -1
}
