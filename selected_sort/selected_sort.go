package selected_sort

/*
Вот подробное описание алгоритма сортировки выбором с дополненным комментарием, включая временную и пространственную сложность, а также другие характеристики:

go

Collapse

Wrap

Copy
package selection_sort

/*
	Сортировка выбором (Selection Sort) — это алгоритм сортировки, который на каждом шаге
	ищет минимальный элемент в неотсортированной части массива и помещает его в конец
	отсортированной части. Алгоритм делит массив на две части: отсортированную (слева) и
	неотсортированную (справа), постепенно увеличивая отсортированную часть.

	Алгоритм:
	1) Изначально отсортированная часть пуста, а неотсортированная — это весь массив.
	2) На каждой итерации:
	   - Проходим по неотсортированной части массива, начиная с текущей позиции i.
	   - Находим индекс минимального элемента в этой части.
	   - Меняем местами текущий элемент (arr[i]) с найденным минимальным (arr[min]).
	3) После каждой итерации отсортированная часть увеличивается на один элемент, а
	   неотсортированная уменьшается.
	4) Процесс продолжается, пока весь массив не станет отсортированным.

Характеристики алгоритма:
	- Устойчивость: Нет, алгоритм неустойчив, так как при обмене элементов может измениться
	  относительный порядок равных элементов (например, при наличии дубликатов).
	- Временная сложность:
	  - O(n²) во всех случаях (лучшем, среднем и худшем), так как:
	    * Внешний цикл выполняется n раз (от 0 до n-1).
	    * Внутренний цикл для каждой итерации i проходит по оставшимся n-i-1 элементам,
	      что в сумме даёт: (n-1) + (n-2) + ... + 1 = n(n-1)/2 операций.
	    * Даже если массив уже отсортирован, поиск минимума всё равно выполняется полностью.
  - Подробно: количество сравнений всегда равно n(n-1)/2, а количество обменов — до n.
	- Пространственная сложность:
	  - O(1) — алгоритм является "in-place" (сортировка на месте), использует только
	    несколько дополнительных переменных (i, j, min), не требуя дополнительной памяти
	    пропорционально размеру массива.
	- Преимущества:
	  - Простота реализации.
	  - Минимальное количество обменов (не более n), что полезно, если операция обмена дорога.
	- Недостатки:
	  - Неэффективен для больших массивов из-за O(n²).
	  - Не адаптивен: не использует преимущества частично отсортированных данных.
*/

func SelectedSort(arr []int) {
	for i := 0; i <= len(arr)-1; i++ {
		min := i

		for j := i + 1; j <= len(arr)-1; j++ {
			if arr[j] < arr[min] {
				min = j
			}
		}

		arr[i], arr[min] = arr[min], arr[i]
	}
}
