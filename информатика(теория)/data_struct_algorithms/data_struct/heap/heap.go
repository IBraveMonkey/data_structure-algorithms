/*
Heap (Куча)

Что это такое?
Heap — это специализированная структура данных в виде полного бинарного дерева, которая удовлетворяет свойству кучи:
в max-heap значение каждого узла больше или равно значениям его потомков, в min-heap — меньше или равно.
Используется для быстрого доступа к минимальному или максимальному элементу.

Зачем это нужно?
- Быстрое получение минимума или максимума (O(1)).
- Эффективная реализация очередей с приоритетами.
- Сортировка данных (Heap Sort).

В чём смысл?
- Дерево всегда сбалансировано (полное бинарное дерево).
- Корень всегда содержит экстремальный элемент (min или max).

Когда использовать?
- Когда нужно часто получать минимальный/максимальный элемент.
- В алгоритмах на графах (Дейкстра, Прим).
- В планировщиках задач (выбор задачи с наивысшим приоритетом).
- Для поиска K самых больших/маленьких элементов в потоке данных.

Как работает?
- Вставка: элемент добавляется в конец дерева и "всплывает" (sift up) на свое место.
- Удаление: корень заменяется последним элементом, который затем "тонет" (sift down).
- Heapify: преобразование массива в кучу за O(n).

### Сложность

| Операция | Временная сложность (O) | Пространственная сложность (O) |
|:---|:---:|:---:|
| Вставка | O(log n) | O(1) |
| Удаление корня (min/max) | O(log n) | O(1) |
| Получение min/max | O(1) | O(1) |
| Построение кучи (Heapify) | O(n) | O(1) |
| Хранение | — | O(n) |

Как понять, что задача подходит под Heap?
- Нужно найти "K самых больших/маленьких" элементов.
- Нужно постоянно получать текущий минимум/максимум из динамически меняющегося набора данных.
- Задача про слияние K отсортированных массивов/списков.
*/

package heap

// IntHeap — это наш массив чисел, который станет кучей
// Реализует интерфейс heap.Interface из стандартной библиотеки container/heap
type IntHeap []int

// Len — возвращает количество элементов
func (h IntHeap) Len() int { return len(h) }

// Less — сравнивает элементы (для min-heap: i < j)
func (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }

// Swap — меняет элементы местами
func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }

// Push — добавляет элемент в конец
func (h *IntHeap) Push(x interface{}) {
	*h = append(*h, x.(int))
}

// Pop — убирает и возвращает последний элемент (корень уже извлечён стандартной библиотекой перед этим вызовом)
func (h *IntHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}
