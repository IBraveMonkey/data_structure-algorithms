package counting_sort

/*
Counting Sort (Сортировка подсчетом)

Что это такое?
Это алгоритм сортировки целых чисел, который работает без сравнения элементов друг с другом.
Вместо сравнений, он "считает" количество вхождений каждого числа и использует эту информацию, чтобы сразу поставить числа на свои места.

Зачем это нужно?
- Сортировать данные МГНОВЕННО (O(n)), преодолевая математический предел O(n log n) для сортировок сравнением.
- Но только при условии, что диапазон чисел (K) небольшой.

В чём смысл?
- Если мы знаем, что число "5" встречается 3 раза, а чисел меньше пятёрки всего 10 штук, мы точно знаем, что пятёрки займут индексы 10, 11 и 12.

Когда использовать?
- Когда сортируем целые числа (или объекты, отображаемые в ключи).
- Когда диапазон значений (K = max-min) не сильно превышает количество элементов (N). Например, сортировка миллиона оценок от 1 до 5.

Как работает?
1. Находим min и max.
2. Создаем массив count размером (max-min+1).
3. Проходим по исходному массиву и увеличиваем счетчик для каждого числа.
4. (Опционально для stable версии) Преобразуем count в массив префиксных сумм (индексы позиций).
5. Заполняем результирующий массив.

Сложность:
- Время: O(N + K).
- Память: O(K) (для массива count).
*/

func CountingSort(arr []int) []int {
	if len(arr) == 0 {
		return arr
	}

	min, max := arr[0], arr[0]
	for _, v := range arr {
		if v < min {
			min = v
		}
		if v > max {
			max = v
		}
	}

	// Создаем массив подсчета
	rangeSize := max - min + 1
	count := make([]int, rangeSize)

	// Считаем частоты
	for _, v := range arr {
		count[v-min]++
	}

	// Перезаписываем исходный массив (для упрощенной версии)
	sortedIndex := 0
	for valOffset, frequency := range count {
		val := valOffset + min
		for frequency > 0 {
			arr[sortedIndex] = val
			sortedIndex++
			frequency--
		}
	}

	return arr
}
