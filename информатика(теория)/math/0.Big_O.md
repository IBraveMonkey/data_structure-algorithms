# üìà Big O Notation (O-–Ω–æ—Ç–∞—Ü–∏—è)

## üìë –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
1. [–ß—Ç–æ —ç—Ç–æ –∏ –∑–∞—á–µ–º?](#1-—á—Ç–æ-—ç—Ç–æ-–∏-–∑–∞—á–µ–º)
2. [–ö–ª–∞—Å—Å—ã —Å–ª–æ–∂–Ω–æ—Å—Ç–∏](#2-–∫–ª–∞—Å—Å—ã-—Å–ª–æ–∂–Ω–æ—Å—Ç–∏)
3. [–ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞ –Ω–∞ Go](#3-–ø—Ä–∏–º–µ—Ä—ã-–∫–æ–¥–∞-–Ω–∞-go)
4. [–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ—Å—Ç–∞](#4-–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è-—Ä–æ—Å—Ç–∞)
5. [Space Complexity](#5-space-complexity)
6. [–î—Ä—É–≥–∏–µ –Ω–æ—Ç–∞—Ü–∏–∏ (Omega, Theta)](#6-–¥—Ä—É–≥–∏–µ-–Ω–æ—Ç–∞—Ü–∏–∏-omega-theta)
7. [–ö–∞–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥](#7-–∫–∞–∫-–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å-–∫–æ–¥)
8. [–®–ø–∞—Ä–≥–∞–ª–∫–∞](#8-—à–ø–∞—Ä–≥–∞–ª–∫–∞)

---

## 1. ü§î –ß—Ç–æ —ç—Ç–æ –∏ –∑–∞—á–µ–º?

**Big O** ‚Äî —ç—Ç–æ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –Ω–æ—Ç–∞—Ü–∏—è, –æ–ø–∏—Å—ã–≤–∞—é—â–∞—è, –∫–∞–∫ –º–µ–Ω—è–µ—Ç—Å—è –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ (–∏–ª–∏ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏) –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö ($n$).

> [!IMPORTANT]
> –ú—ã –Ω–µ —Å—á–∏—Ç–∞–µ–º —Å–µ–∫—É–Ω–¥—ã. –ú—ã —Å—á–∏—Ç–∞–µ–º **–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π**. –ü–æ—Ç–æ–º—É —á—Ç–æ —Å–µ–∫—É–Ω–¥—ã –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞, –∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–ø–µ—Ä–∞—Ü–∏–π ‚Äî –æ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞.

### –¢—Ä–∏ —Å–ª—É—á–∞—è

*   **Best Case** (–ª—É—á—à–∏–π): –û–±—ã—á–Ω–æ –Ω–µ –∏–Ω—Ç–µ—Ä–µ—Å–µ–Ω (–Ω–∞–ø—Ä–∏–º–µ—Ä, —ç–ª–µ–º–µ–Ω—Ç –Ω–∞–π–¥–µ–Ω —Å—Ä–∞–∑—É)
*   **Average Case** (—Å—Ä–µ–¥–Ω–∏–π): –í–∞–∂–µ–Ω –¥–ª—è —Ä–µ–∞–ª—å–Ω–æ–π –æ—Ü–µ–Ω–∫–∏
*   **Worst Case** (—Ö—É–¥—à–∏–π) = **Big O**: –°–∞–º—ã–π –≤–∞–∂–Ω—ã–π! "–•—É–∂–µ —ç—Ç–æ–≥–æ –Ω–µ –±—É–¥–µ—Ç"

> [!TIP]
> **–ü–æ—á–µ–º—É Worst Case?** –ü–æ—Ç–æ–º—É —á—Ç–æ –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –Ω—É–∂–Ω–æ –±—ã—Ç—å –≥–æ—Ç–æ–≤—ã–º –∫ —Ö—É–¥—à–µ–º—É —Å—Ü–µ–Ω–∞—Ä–∏—é. –ï—Å–ª–∏ –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç–∞–µ—Ç –∑–∞ O(n¬≤) –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ, —Ç–æ –ø—Ä–∏ –±–æ–ª—å—à–æ–º n –æ–Ω –º–æ–∂–µ—Ç "—É–ø–∞—Å—Ç—å".

---

## 2. üê¢ –ö–ª–∞—Å—Å—ã —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ (–æ—Ç –ª—É—á—à–µ–≥–æ –∫ —Ö—É–¥—à–µ–º—É)

### O(1) ‚Äî Constant Time ‚ö°

–í—Ä–µ–º—è **–Ω–µ –∑–∞–≤–∏—Å–∏—Ç** –æ—Ç —Ä–∞–∑–º–µ—Ä–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –í—Å–µ–≥–¥–∞ –æ–¥–∏–Ω–∞–∫–æ–≤–æ –±—ã—Å—Ç—Ä–æ.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   –í–∑—è—Ç—å —ç–ª–µ–º–µ–Ω—Ç –º–∞—Å—Å–∏–≤–∞ –ø–æ –∏–Ω–¥–µ–∫—Å—É: `arr[5]`
*   –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ HashMap: `m["key"]`
*   –î–æ–±–∞–≤–∏—Ç—å —ç–ª–µ–º–µ–Ω—Ç –≤ –∫–æ–Ω–µ—Ü slice (–µ—Å–ª–∏ –Ω–µ –Ω—É–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ): `append(slice, item)`

---

### O(log n) ‚Äî Logarithmic Time üöÄ

–ù–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º **–ø–æ–ª–æ–≤–∏–Ω—É** –¥–∞–Ω–Ω—ã—Ö. –û—á–µ–Ω—å —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ!

**–ü—Ä–∏–º–µ—Ä—ã:**
*   Binary Search (–±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫) –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
*   –ü–æ–∏—Å–∫ –≤ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –¥–µ—Ä–µ–≤–µ (AVL, Red-Black Tree)
*   –û–ø–µ—Ä–∞—Ü–∏–∏ –≤ –∫—É—á–µ (heap)

> [!NOTE]
> $\log_2(1,000,000) \approx 20$. –¢–æ –µ—Å—Ç—å –¥–ª—è –º–∏–ª–ª–∏–æ–Ω–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω—É–∂–Ω–æ –≤—Å–µ–≥–æ ~20 –æ–ø–µ—Ä–∞—Ü–∏–π!

---

### O(n) ‚Äî Linear Time üìè

–ù—É–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –ø–æ –≤—Å–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞–º **1 —Ä–∞–∑**.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   –ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º—É–º –≤ –º–∞—Å—Å–∏–≤–µ (–Ω—É–∂–Ω–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã)
*   –ü—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –Ω–µ–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
*   –ü–æ–¥—Å—á–µ—Ç —Å—É–º–º—ã —ç–ª–µ–º–µ–Ω—Ç–æ–≤

---

### O(n log n) ‚Äî Linearithmic Time ‚öôÔ∏è

–°—Ç–∞–Ω–¥–∞—Ä—Ç –¥–ª—è **—Ö–æ—Ä–æ—à–∏—Ö** –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   Merge Sort (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å–ª–∏—è–Ω–∏–µ–º)
*   Quick Sort (–±—ã—Å—Ç—Ä–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞) ‚Äî –≤ —Å—Ä–µ–¥–Ω–µ–º —Å–ª—É—á–∞–µ
*   Heap Sort

**–°—É—Ç—å:** –ú—ã –¥–µ–ª–∞–µ–º $n$ —Ä–∞–∑ –¥–µ–π—Å—Ç–≤–∏–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é $\log n$.

---

### O(n¬≤) ‚Äî Quadratic Time üêå

–í–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   Bubble Sort (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø—É–∑—ã—Ä—å–∫–æ–º)
*   Selection Sort
*   –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –ø–∞—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞–π—Ç–∏ –¥—É–±–ª–∏–∫–∞—Ç—ã –Ω–∞–∏–≤–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º)

> [!WARNING]
> –ü—Ä–∏ n = 10,000 –ø–æ–ª—É—á–∏—Ç—Å—è 100,000,000 –æ–ø–µ—Ä–∞—Ü–∏–π! –û—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö.

---

### O(2‚Åø) ‚Äî Exponential Time üí£

–ö–∞–∂–¥—ã–π –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç **—É–¥–≤–∞–∏–≤–∞–µ—Ç** –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã. –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ –¥–ª—è –±–æ–ª—å—à–∏—Ö n.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Ä–∞—Å—á–µ—Ç —á–∏—Å–µ–ª –§–∏–±–æ–Ω–∞—á—á–∏ (–±–µ–∑ –ºemoization)
*   –ü–µ—Ä–µ–±–æ—Ä –≤—Å–µ—Ö –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤ –º–Ω–æ–∂–µ—Å—Ç–≤–∞
*   –†–µ—à–µ–Ω–∏–µ –∑–∞–¥–∞—á –ø–æ–ª–Ω—ã–º –ø–µ—Ä–µ–±–æ—Ä–æ–º (brute force)

---

### O(n!) ‚Äî Factorial Time ‚ò†Ô∏è

–•—É–∂–µ –Ω–µ–∫—É–¥–∞. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ—Ä–µ–∞–ª—å–Ω–æ –¥–ª—è n > 15.

**–ü—Ä–∏–º–µ—Ä—ã:**
*   –ó–∞–¥–∞—á–∞ –∫–æ–º–º–∏–≤–æ—è–∂–µ—Ä–∞ (Traveling Salesman Problem) ‚Äî –ø–æ–ª–Ω—ã–π –ø–µ—Ä–µ–±–æ—Ä
*   –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–æ–∫

> [!CAUTION]
> $10! = 3,628,800$, –∞ $20! = 2.4 \times 10^{18}$ ‚Äî —ç—Ç–æ —Ç—Ä–∏–ª–ª–∏–æ–Ω—ã —Ç—Ä–∏–ª–ª–∏–æ–Ω–æ–≤ –æ–ø–µ—Ä–∞—Ü–∏–π!

---

## 3. üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞ –Ω–∞ Go

### O(1) ‚Äî –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è

```go
// –î–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –º–∞—Å—Å–∏–≤–∞
func getElement(arr []int, index int) int {
    return arr[index] // O(1)
}

// –í—Å—Ç–∞–≤–∫–∞ –≤ HashMap
func insertToMap(m map[string]int, key string, value int) {
    m[key] = value // O(1) –≤ —Å—Ä–µ–¥–Ω–µ–º
}
```

---

### O(log n) ‚Äî –õ–æ–≥–∞—Ä–∏—Ñ–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è

```go
// –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    
    for left <= right {
        mid := left + (right-left)/2
        
        if arr[mid] == target {
            return mid // –ù–∞—à–ª–∏
        } else if arr[mid] < target {
            left = mid + 1 // –ò—â–µ–º –≤ –ø—Ä–∞–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        } else {
            right = mid - 1 // –ò—â–µ–º –≤ –ª–µ–≤–æ–π –ø–æ–ª–æ–≤–∏–Ω–µ
        }
    }
    
    return -1 // –ù–µ –Ω–∞—à–ª–∏
}
```

**–ü–æ—á–µ–º—É O(log n)?** –ö–∞–∂–¥–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è –¥–µ–ª–∏—Ç –º–∞—Å—Å–∏–≤ –ø–æ–ø–æ–ª–∞–º. –î–ª—è 1000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω—É–∂–Ω–æ ~10 –∏—Ç–µ—Ä–∞—Ü–∏–π ($\log_2(1000) \approx 10$).

---

### O(n) ‚Äî –õ–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è

```go
// –ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º—É–º –≤ –º–∞—Å—Å–∏–≤–µ
func findMax(arr []int) int {
    if len(arr) == 0 {
        return 0
    }
    
    max := arr[0]
    for _, num := range arr { // –ü—Ä–æ—Ö–æ–¥–∏–º –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç 1 —Ä–∞–∑
        if num > max {
            max = num
        }
    }
    return max
}

// –ü–æ–¥—Å—á–µ—Ç —Å—É–º–º—ã
func sum(arr []int) int {
    total := 0
    for _, num := range arr { // O(n)
        total += num
    }
    return total
}
```

---

### O(n log n) ‚Äî –õ–∏–Ω–µ–∞—Ä–∏—Ç–º–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è

```go
// Merge Sort
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])   // –†–µ–∫—É—Ä—Å–∏—è: log(n) —É—Ä–æ–≤–Ω–µ–π
    right := mergeSort(arr[mid:])
    
    return merge(left, right)      // –°–ª–∏—è–Ω–∏–µ: O(n)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    
    for i < len(left) && j < len(right) {
        if left[i] < right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

---

### O(n¬≤) ‚Äî –ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ –≤—Ä–µ–º—è

```go
// Bubble Sort (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø—É–∑—ã—Ä—å–∫–æ–º)
func bubbleSort(arr []int) {
    n := len(arr)
    
    for i := 0; i < n; i++ {           // –í–Ω–µ—à–Ω–∏–π —Ü–∏–∫–ª: n —Ä–∞–∑
        for j := 0; j < n-i-1; j++ {   // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ü–∏–∫–ª: n —Ä–∞–∑
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j] // Swap
            }
        }
    }
}

// –ù–∞–π—Ç–∏ –≤—Å–µ –ø–∞—Ä—ã —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å—É–º–º–æ–π (–Ω–∞–∏–≤–Ω—ã–π –ø–æ–¥—Ö–æ–¥)
func findPairs(arr []int, target int) [][2]int {
    pairs := [][2]int{}
    
    for i := 0; i < len(arr); i++ {        // n –∏—Ç–µ—Ä–∞—Ü–∏–π
        for j := i + 1; j < len(arr); j++ { // n –∏—Ç–µ—Ä–∞—Ü–∏–π
            if arr[i]+arr[j] == target {
                pairs = append(pairs, [2]int{arr[i], arr[j]})
            }
        }
    }
    
    return pairs
}
```

---

### O(2‚Åø) ‚Äî –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è

```go
// –§–∏–±–æ–Ω–∞—á—á–∏ (–Ω–∞–∏–≤–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏—è)
func fibonacci(n int) int {
    if n <= 1 {
        return n
    }
    // –ö–∞–∂–¥—ã–π –≤—ã–∑–æ–≤ –ø–æ—Ä–æ–∂–¥–∞–µ—Ç 2 –Ω–æ–≤—ã—Ö –≤—ã–∑–æ–≤–∞
    return fibonacci(n-1) + fibonacci(n-2) // O(2^n) - –ü–õ–û–•–û!
}

// –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –ºemoization - O(n)
func fibonacciMemo(n int, memo map[int]int) int {
    if n <= 1 {
        return n
    }
    
    if val, ok := memo[n]; ok {
        return val // –£–∂–µ –ø–æ—Å—á–∏—Ç–∞–ª–∏
    }
    
    memo[n] = fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo)
    return memo[n]
}
```

---

## 4. üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–æ—Å—Ç–∞

–ü–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Ä–∞—Å—Ç–µ—Ç –≤—Ä–µ–º—è –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ n:

```mermaid
graph LR
    subgraph "n = 10"
        O1_10["O(1): 1"]
        Olog_10["O(log n): 3"]
        On_10["O(n): 10"]
        Onlogn_10["O(n log n): 33"]
        On2_10["O(n¬≤): 100"]
        O2n_10["O(2‚Åø): 1024"]
    end
    
    subgraph "n = 100"
        O1_100["O(1): 1"]
        Olog_100["O(log n): 7"]
        On_100["O(n): 100"]
        Onlogn_100["O(n log n): 664"]
        On2_100["O(n¬≤): 10,000"]
        O2n_100["O(2‚Åø): 10¬≥‚Å∞ üíÄ"]
    end
    
    subgraph "n = 1000"
        O1_1000["O(1): 1"]
        Olog_1000["O(log n): 10"]
        On_1000["O(n): 1000"]
        Onlogn_1000["O(n log n): 9966"]
        On2_1000["O(n¬≤): 1,000,000"]
        O2n_1000["O(2‚Åø): ‚àû ‚ò†Ô∏è"]
    end
```

| n | O(1) | O(log n) | O(n) | O(n log n) | O(n¬≤) | O(2‚Åø) |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **10** | 1 | 3 | 10 | 33 | 100 | 1,024 |
| **100** | 1 | 7 | 100 | 664 | 10,000 | 10¬≥‚Å∞ üíÄ |
| **1,000** | 1 | 10 | 1,000 | 9,966 | 1,000,000 | ‚àû ‚ò†Ô∏è |
| **10,000** | 1 | 13 | 10,000 | 132,877 | 100,000,000 | ‚Äî |

---

## 5. üíæ Space Complexity

–¢–æ –∂–µ —Å–∞–º–æ–µ, –Ω–æ –ø—Ä–æ **–ø–∞–º—è—Ç—å**. –°–∫–æ–ª—å–∫–æ **–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π** –ø–∞–º—è—Ç–∏ –Ω—É–∂–Ω–æ –∞–ª–≥–æ—Ä–∏—Ç–º—É?

### –ü—Ä–∏–º–µ—Ä—ã

```go
// O(1) Space - –ö–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–∞—è –ø–∞–º—è—Ç—å
func reverseInPlace(arr []int) {
    left, right := 0, len(arr)-1
    for left < right {
        arr[left], arr[right] = arr[right], arr[left]
        left++
        right--
    }
    // –¢–æ–ª—å–∫–æ 2 –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (left, right) –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç n
}

// O(n) Space - –õ–∏–Ω–µ–π–Ω–∞—è –ø–∞–º—è—Ç—å
func mergeSortExample(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤ —Ä–∞–∑–º–µ—Ä–æ–º n
    return merge(left, right) // O(n) –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏
}
```

> [!TIP]
> **In-place –∞–ª–≥–æ—Ä–∏—Ç–º—ã** (O(1) space) –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ, –µ—Å–ª–∏ –ø–∞–º—è—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö).

---

## 6. üìê –î—Ä—É–≥–∏–µ –Ω–æ—Ç–∞—Ü–∏–∏ (Omega, Theta)

Big O ‚Äî –Ω–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –Ω–æ—Ç–∞—Ü–∏—è! –ï—Å—Ç—å –∏ –¥—Ä—É–≥–∏–µ:

### Œ© (Omega) ‚Äî –ù–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞

**–õ—É—á—à–∏–π —Å–ª—É—á–∞–π**. –ê–ª–≥–æ—Ä–∏—Ç–º –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å **–±—ã—Å—Ç—Ä–µ–µ** —ç—Ç–æ–≥–æ.

*   **–ü—Ä–∏–º–µ—Ä**: –ü–æ–∏—Å–∫ –º–∏–Ω–∏–º—É–º–∞ –≤ –Ω–µ–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ ‚Äî **Œ©(n)**, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω—É–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Ö–æ—Ç—è –±—ã —Ä–∞–∑.

---

### Œò (Theta) ‚Äî –¢–æ—á–Ω–∞—è –≥—Ä–∞–Ω–∏—Ü–∞

–ê–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç–∞–µ—Ç **—Ä–æ–≤–Ω–æ** —Å —Ç–∞–∫–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é (–∏ –ª—É—á—à–∏–π, –∏ —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç).

*   **–ü—Ä–∏–º–µ—Ä**: –ü–æ–¥—Å—á–µ—Ç —Å—É–º–º—ã –º–∞—Å—Å–∏–≤–∞ ‚Äî **Œò(n)**, –≤—Å–µ–≥–¥–∞ –ø—Ä–æ—Ö–æ–¥–∏–º –≤—Å–µ n —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

---

### o (Little-o) ‚Äî –°—Ç—Ä–æ–≥–∞—è –≤–µ—Ä—Ö–Ω—è—è –≥—Ä–∞–Ω–∏—Ü–∞

–ê–ª–≥–æ—Ä–∏—Ç–º —Ä–∞–±–æ—Ç–∞–µ—Ç **—Å—Ç—Ä–æ–≥–æ –±—ã—Å—Ç—Ä–µ–µ**, —á–µ–º —É–∫–∞–∑–∞–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è.

*   **–ü—Ä–∏–º–µ—Ä**: O(n) —Ç–∞–∫–∂–µ o(n¬≤), –ø–æ—Ç–æ–º—É —á—Ç–æ n —Ä–∞—Å—Ç–µ—Ç –º–µ–¥–ª–µ–Ω–Ω–µ–µ n¬≤.

---

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ

| –ù–æ—Ç–∞—Ü–∏—è | –°–º—ã—Å–ª | –ü—Ä–∏–º–µ—Ä |
|:---|:---|:---|
| **O (Big-O)** | –•—É–¥—à–∏–π —Å–ª—É—á–∞–π (‚â§) | "–ù–µ –º–µ–¥–ª–µ–Ω–Ω–µ–µ —á–µ–º..." |
| **Œ© (Omega)** | –õ—É—á—à–∏–π —Å–ª—É—á–∞–π (‚â•) | "–ù–µ –±—ã—Å—Ç—Ä–µ–µ —á–µ–º..." |
| **Œò (Theta)** | –¢–æ—á–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ (=) | "–†–æ–≤–Ω–æ..." |
| **o (Little-o)** | –°—Ç—Ä–æ–≥–æ –º–µ–Ω—å—à–µ (<) | "–°—Ç—Ä–æ–≥–æ –±—ã—Å—Ç—Ä–µ–µ —á–µ–º..." |

> [!NOTE]
> –í 99% —Å–ª—É—á–∞–µ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è **Big O**, –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç —Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π.

---

## 7. üõ†Ô∏è –ö–∞–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥?

### –ü—Ä–∞–≤–∏–ª–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏

1. **–ò–∑–±–µ–≥–∞–π—Ç–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤** (O(n¬≤)):
   ```go
   // ‚ùå –ü–õ–û–•–û: O(n¬≤)
   for i := 0; i < len(arr); i++ {
       for j := 0; j < len(arr); j++ {
           // ...
       }
   }
   
   // ‚úÖ –•–û–†–û–®–û: O(n) —Å HashMap
   seen := make(map[int]bool)
   for _, num := range arr {
       if seen[num] {
           // –ù–∞—à–ª–∏ –¥—É–±–ª–∏–∫–∞—Ç
       }
       seen[num] = true
   }
   ```

2. **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö**:
   - –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ ‚Üí HashMap (O(1))
   - –°–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ ‚Üí Binary Search (O(log n))
   - –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã ‚Üí Heap (O(log n))

3. **Memoization –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–∏**:
   ```go
   // –ö–µ—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞—Ç—å
   memo := make(map[int]int)
   result := fibonacciMemo(50, memo) // O(n) –≤–º–µ—Å—Ç–æ O(2^n)
   ```

4. **–†–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ –∏–∑ —Ü–∏–∫–ª–∞**:
   ```go
   // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ - —Å—Ä–∞–∑—É –≤—ã—Ö–æ–¥–∏–º
   for _, num := range arr {
       if num == target {
           return true // –ù–µ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏—Å–∫–∞—Ç—å
       }
   }
   ```

---

## 8. üìù –®–ø–∞—Ä–≥–∞–ª–∫–∞

| –°–ª–æ–∂–Ω–æ—Å—Ç—å | –ù–∞–∑–≤–∞–Ω–∏–µ | –ü—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ n –≤ 10 —Ä–∞–∑, –≤—Ä–µ–º—è... | –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ |
|:---|:---|:---|:---|
| **O(1)** | Constant | –ù–µ –º–µ–Ω—è–µ—Ç—Å—è | HashMap, array access |
| **O(log n)** | Logarithmic | +–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞ (–Ω–µ–º–Ω–æ–≥–æ) | Binary Search, –¥–µ—Ä–µ–≤—å—è |
| **O(n)** | Linear | √ó10 | –ü—Ä–æ—Å—Ç–æ–π –ø–æ–∏—Å–∫, —Å—É–º–º–∞ |
| **O(n log n)** | Linearithmic | √ó10 (—á—É—Ç—å –±–æ–ª—å—à–µ) | Merge Sort, Quick Sort |
| **O(n¬≤)** | Quadratic | √ó100 | Bubble Sort, –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã |
| **O(2‚Åø)** | Exponential | üíÄ –í–∑—Ä—ã–≤ (10‚Üí1024) | –§–∏–±–æ–Ω–∞—á—á–∏ (–Ω–∞–∏–≤), –ø–µ—Ä–µ–±–æ—Ä |
| **O(n!)** | Factorial | ‚ò†Ô∏è –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ | –ü–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏, TSP |

---

## üí° –ò—Ç–æ–≥–æ–≤—ã–µ —Å–æ–≤–µ—Ç—ã

1. **–í—Å–µ–≥–¥–∞ –¥—É–º–∞–π—Ç–µ –æ Big O** –ø—Ä–∏ –Ω–∞–ø–∏—Å–∞–Ω–∏–∏ –∫–æ–¥–∞
2. **O(n log n) ‚Äî —ç—Ç–æ —Ö–æ—Ä–æ—à–æ** –¥–ª—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
3. **O(n¬≤) ‚Äî –ø–ª–æ—Ö–æ** –¥–ª—è –±–æ–ª—å—à–æ–≥–æ n
4. **O(2‚Åø) –∏ O(n!) ‚Äî –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞**, –∏–∑–±–µ–≥–∞–π—Ç–µ —ç—Ç–æ–≥–æ
5. **HashMap ‚Äî –≤–∞—à –¥—Ä—É–≥** –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ O(n¬≤) ‚Üí O(n)
