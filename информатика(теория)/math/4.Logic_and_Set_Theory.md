# üß† Logic and Set Theory (–õ–æ–≥–∏–∫–∞ –∏ –¢–µ–æ—Ä–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤)

## üìë –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ
1. [–ë—É–ª–µ–≤–∞ –ª–æ–≥–∏–∫–∞](#1-–±—É–ª–µ–≤–∞-–ª–æ–≥–∏–∫–∞)
2. [–¢–∞–±–ª–∏—Ü—ã –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏](#2-—Ç–∞–±–ª–∏—Ü—ã-–∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏)
3. [–¢–µ–æ—Ä–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤ (Set Theory)](#3-—Ç–µ–æ—Ä–∏—è-–º–Ω–æ–∂–µ—Å—Ç–≤-set-theory)
4. [–ó–∞–∫–æ–Ω—ã –¥–µ –ú–æ—Ä–≥–∞–Ω–∞](#4-–∑–∞–∫–æ–Ω—ã-–¥–µ-–º–æ—Ä–≥–∞–Ω–∞)
5. [–†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ Go](#5-—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è-–Ω–∞-go)

---

## 1. üö¶ –ë—É–ª–µ–≤–∞ –ª–æ–≥–∏–∫–∞

–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ç–æ–ª—å–∫–æ –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è: `True` (1) –∏–ª–∏ `False` (0).

–û—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:
*   **NOT (–ù–ï, `!`)**: –ú–µ–Ω—è–µ—Ç –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–µ
*   **AND (–ò, `&&`)**: –ò—Å—Ç–∏–Ω–Ω–æ, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ **–û–ë–ê** –∏—Å—Ç–∏–Ω–Ω—ã
*   **OR (–ò–õ–ò, `||`)**: –ò—Å—Ç–∏–Ω–Ω–æ, –µ—Å–ª–∏ **–•–û–¢–Ø –ë–´ –û–î–ò–ù** –∏—Å—Ç–∏–Ω–µ–Ω
*   **XOR (–ò—Å–∫–ª—é—á–∞—é—â–µ–µ –ò–õ–ò, `^`)**: –ò—Å—Ç–∏–Ω–Ω–æ, –µ—Å–ª–∏ –æ–Ω–∏ **–†–ê–ó–ù–´–ï**

### –ü—Ä–∏–º–µ—Ä—ã –Ω–∞ Go

```go
func logicExamples() {
    a, b := true, false
    
    // NOT
    fmt.Println(!a)      // false
    fmt.Println(!b)      // true
    
    // AND
    fmt.Println(a && a)  // true
    fmt.Println(a && b)  // false
    fmt.Println(b && b)  // false
    
    // OR
    fmt.Println(a || a)  // true
    fmt.Println(a || b)  // true
    fmt.Println(b || b)  // false
    
    // XOR (–≤ Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è ^ –¥–ª—è —á–∏—Å–µ–ª, –¥–ª—è bool –¥–µ–ª–∞–µ–º —Ç–∞–∫:)
    fmt.Println(a != b)  // true (—Ä–∞–∑–Ω—ã–µ)
    fmt.Println(a != a)  // false (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ)
}
```

### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ: —É—Å–ª–æ–≤–∏—è

```go
func canVote(age int, isCitizen bool) bool {
    // –ú–æ–∂–Ω–æ –≥–æ–ª–æ—Å–æ–≤–∞—Ç—å, –µ—Å–ª–∏ –≤–æ–∑—Ä–∞—Å—Ç >= 18 –ò –≥—Ä–∞–∂–¥–∞–Ω–∏–Ω
    return age >= 18 && isCitizen
}

func canEnter(hasTicket bool, isVIP bool) bool {
    // –ú–æ–∂–Ω–æ –≤–æ–π—Ç–∏, –µ—Å–ª–∏ –µ—Å—Ç—å –±–∏–ª–µ—Ç –ò–õ–ò VIP —Å—Ç–∞—Ç—É—Å
    return hasTicket || isVIP
}

func accessAllowed(isAdmin bool, isOwner bool, hasPermission bool) bool {
    // –î–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω, –µ—Å–ª–∏ (–∞–¥–º–∏–Ω –ò–õ–ò –≤–ª–∞–¥–µ–ª–µ—Ü) –ò –µ—Å—Ç—å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
    return (isAdmin || isOwner) && hasPermission
}
```

---

## 2. üìä –¢–∞–±–ª–∏—Ü—ã –∏—Å—Ç–∏–Ω–Ω–æ—Å—Ç–∏

| A | B | NOT A | A AND B | A OR B | A XOR B |
|:---:|:---:|:---:|:---:|:---:|:---:|
| 0 | 0 | 1 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 1 | 1 | 0 |

### –ë–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ Go

```go
func bitwiseExamples() {
    a, b := 5, 3  // 5 = 0101, 3 = 0011 –≤ –¥–≤–æ–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ
    
    // AND (&): –æ–±–∞ –±–∏—Ç–∞ 1
    fmt.Printf("%d & %d = %d (0101 & 0011 = 0001)\n", a, b, a&b) // 1
    
    // OR (|): —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –±–∏—Ç 1
    fmt.Printf("%d | %d = %d (0101 | 0011 = 0111)\n", a, b, a|b) // 7
    
    // XOR (^): –±–∏—Ç—ã —Ä–∞–∑–Ω—ã–µ
    fmt.Printf("%d ^ %d = %d (0101 ^ 0011 = 0110)\n", a, b, a^b) // 6
    
    // NOT (^): –∏–Ω–≤–µ—Ä—Å–∏—è –±–∏—Ç–æ–≤ (–≤ Go –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è ^x)
    fmt.Printf("^%d = %d\n", a, ^a) // -6 (–∏–Ω–≤–µ—Ä—Å–∏—è –≤—Å–µ—Ö –±–∏—Ç–æ–≤)
    
    // –°–¥–≤–∏–≥–∏
    fmt.Printf("%d << 1 = %d (—É–º–Ω–æ–∂–µ–Ω–∏–µ –Ω–∞ 2)\n", a, a<<1)  // 10
    fmt.Printf("%d >> 1 = %d (–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ 2)\n", a, a>>1)    // 2
}
```

### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ: —Ñ–ª–∞–≥–∏ –∏ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞

```go
const (
    ReadPermission  = 1 << 0 // 0001 = 1
    WritePermission = 1 << 1 // 0010 = 2
    ExecPermission  = 1 << 2 // 0100 = 4
    AdminPermission = 1 << 3 // 1000 = 8
)

func hasPermission(userPerms, requiredPerm int) bool {
    return (userPerms & requiredPerm) == requiredPerm
}

func addPermission(userPerms, newPerm int) int {
    return userPerms | newPerm
}

func removePermission(userPerms, perm int) int {
    return userPerms &^ perm // AND NOT
}

func main() {
    // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∞ READ –∏ WRITE
    user := ReadPermission | WritePermission // 0011 = 3
    
    fmt.Println(hasPermission(user, ReadPermission))   // true
    fmt.Println(hasPermission(user, WritePermission))  // true
    fmt.Println(hasPermission(user, ExecPermission))   // false
    
    // –î–æ–±–∞–≤–ª—è–µ–º EXEC
    user = addPermission(user, ExecPermission) // 0111 = 7
    fmt.Println(hasPermission(user, ExecPermission))   // true
    
    // –£–±–∏—Ä–∞–µ–º WRITE
    user = removePermission(user, WritePermission) // 0101 = 5
    fmt.Println(hasPermission(user, WritePermission))  // false
}
```

---

## 3. üì¶ –¢–µ–æ—Ä–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤ (Set Theory)

**–ú–Ω–æ–∂–µ—Å—Ç–≤–æ** ‚Äî —ç—Ç–æ –∫–æ–ª–ª–µ–∫—Ü–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ (–±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤).

### –û—Å–Ω–æ–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

*   **–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ (Union, $\cup$)**: –í—Å–µ –∏–∑ A **–ò–õ–ò** B
*   **–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (Intersection, $\cap$)**: –¢–æ–ª—å–∫–æ —Ç–æ, —á—Ç–æ –µ—Å—Ç—å –∏ –≤ A, **–ò** –≤ B
*   **–†–∞–∑–Ω–æ—Å—Ç—å (Difference, $A \setminus B$)**: –ï—Å—Ç—å –≤ A, –Ω–æ **–ù–ï–¢** –≤ B
*   **–°–∏–º–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è —Ä–∞–∑–Ω–æ—Å—Ç—å**: $(A \setminus B) \cup (B \setminus A)$

```mermaid
flowchart TD
    subgraph "A ‚à™ B (–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ)"
        A1["A: {1, 2, 3}"]
        B1["B: {3, 4, 5}"]
        R1["–†–µ–∑—É–ª—å—Ç–∞—Ç: {1, 2, 3, 4, 5}"]
    end
    
    subgraph "A ‚à© B (–ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ)"
        A2["A: {1, 2, 3}"]
        B2["B: {3, 4, 5}"]
        R2["–†–µ–∑—É–ª—å—Ç–∞—Ç: {3}"]
    end
    
    subgraph "A \\ B (–†–∞–∑–Ω–æ—Å—Ç—å)"
        A3["A: {1, 2, 3}"]
        B3["B: {3, 4, 5}"]
        R3["–†–µ–∑—É–ª—å—Ç–∞—Ç: {1, 2}"]
    end
```

---

## 4. ‚öñÔ∏è –ó–∞–∫–æ–Ω—ã –¥–µ –ú–æ—Ä–≥–∞–Ω–∞

–û—á–µ–Ω—å –≤–∞–∂–Ω—ã–µ –∑–∞–∫–æ–Ω—ã –¥–ª—è —É–ø—Ä–æ—â–µ–Ω–∏—è –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π:

1.  **!(A && B) == !A || !B**  
    "–ù–ï (A –ò B)" = "–ù–ï A –ò–õ–ò –ù–ï B"

2.  **!(A || B) == !A && !B**  
    "–ù–ï (A –ò–õ–ò B)" = "–ù–ï A –ò –ù–ï B"

### –ü—Ä–∏–º–µ—Ä –Ω–∞ Go

```go
func deMorganExample() {
    a, b := true, false
    
    // –ó–∞–∫–æ–Ω 1: !(A && B) == !A || !B
    left1 := !(a && b)
    right1 := !a || !b
    fmt.Println(left1 == right1) // true
    
    // –ó–∞–∫–æ–Ω 2: !(A || B) == !A && !B
    left2 := !(a || b)
    right2 := !a && !b
    fmt.Println(left2 == right2) // true
}
```

### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ: —É–ø—Ä–æ—â–µ–Ω–∏–µ —É—Å–ª–æ–≤–∏–π

```go
// ‚ùå –ü–õ–û–•–û: —Å–ª–æ–∂–Ω–æ —á–∏—Ç–∞—Ç—å
if !(age >= 18 && hasDrivingLicense) {
    fmt.Println("–ù–µ–ª—å–∑—è –≤–æ–¥–∏—Ç—å")
}

// ‚úÖ –•–û–†–û–®–û: –ø—Ä–∏–º–µ–Ω–∏–ª–∏ –∑–∞–∫–æ–Ω –¥–µ –ú–æ—Ä–≥–∞–Ω–∞
if age < 18 || !hasDrivingLicense {
    fmt.Println("–ù–µ–ª—å–∑—è –≤–æ–¥–∏—Ç—å")
}
```

---

## 5. üíª –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ Go

### Set (–ú–Ω–æ–∂–µ—Å—Ç–≤–æ) —á–µ—Ä–µ–∑ map

–í Go –Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ Set, –Ω–æ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `map[T]bool`:

```go
type Set map[int]bool

func NewSet(values ...int) Set {
    s := make(Set)
    for _, v := range values {
        s[v] = true
    }
    return s
}

func (s Set) Add(value int) {
    s[value] = true
}

func (s Set) Remove(value int) {
    delete(s, value)
}

func (s Set) Contains(value int) bool {
    return s[value]
}

func (s Set) Size() int {
    return len(s)
}

// –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ (Union)
func (s Set) Union(other Set) Set {
    result := NewSet()
    for k := range s {
        result.Add(k)
    }
    for k := range other {
        result.Add(k)
    }
    return result
}

// –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (Intersection)
func (s Set) Intersection(other Set) Set {
    result := NewSet()
    for k := range s {
        if other.Contains(k) {
            result.Add(k)
        }
    }
    return result
}

// –†–∞–∑–Ω–æ—Å—Ç—å (Difference)
func (s Set) Difference(other Set) Set {
    result := NewSet()
    for k := range s {
        if !other.Contains(k) {
            result.Add(k)
        }
    }
    return result
}

func main() {
    a := NewSet(1, 2, 3, 4)
    b := NewSet(3, 4, 5, 6)
    
    fmt.Println("A:", a)                    // {1:true, 2:true, 3:true, 4:true}
    fmt.Println("B:", b)                    // {3:true, 4:true, 5:true, 6:true}
    
    union := a.Union(b)
    fmt.Println("A ‚à™ B:", union)            // {1, 2, 3, 4, 5, 6}
    
    intersection := a.Intersection(b)
    fmt.Println("A ‚à© B:", intersection)     // {3, 4}
    
    difference := a.Difference(b)
    fmt.Println("A \\ B:", difference)      // {1, 2}
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞

```go
func (s Set) IsSubsetOf(other Set) bool {
    for k := range s {
        if !other.Contains(k) {
            return false
        }
    }
    return true
}

func main() {
    a := NewSet(1, 2)
    b := NewSet(1, 2, 3, 4)
    
    fmt.Println(a.IsSubsetOf(b)) // true: A ‚äÜ B
    fmt.Println(b.IsSubsetOf(a)) // false
}
```

---

## üí° –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ —Ä–µ–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö

### 1. –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö

```go
func filterActiveUsers(allUsers, bannedUsers Set) Set {
    // –ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ = –í—Å–µ - –ó–∞–±–∞–Ω–µ–Ω–Ω—ã–µ
    return allUsers.Difference(bannedUsers)
}
```

### 2. –ü–æ–∏—Å–∫ –æ–±—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤

```go
func findCommonInterests(user1Interests, user2Interests Set) Set {
    // –û–±—â–∏–µ –∏–Ω—Ç–µ—Ä–µ—Å—ã = –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
    return user1Interests.Intersection(user2Interests)
}
```

### 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏

```go
func hasDuplicates(arr []int) bool {
    seen := NewSet()
    for _, num := range arr {
        if seen.Contains(num) {
            return true // –î—É–±–ª–∏–∫–∞—Ç –Ω–∞–π–¥–µ–Ω
        }
        seen.Add(num)
    }
    return false
}
```

---

## üí° –ò—Ç–æ–≥

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è | –û–ø–µ—Ä–∞—Ü–∏—è | Go –∫–æ–¥ |
|:---|:---|:---|
| **–õ–æ–≥–∏–∫–∞** | AND, OR, NOT, XOR | `&&`, `||`, `!`, `!=` |
| **–ë–∏—Ç–æ–≤—ã–µ** | &, |, ^, << >> | –§–ª–∞–≥–∏, –º–∞—Å–∫–∏ |
| **–ú–Ω–æ–∂–µ—Å—Ç–≤–∞** | Union, Intersection | `map[T]bool` |
| **–ó–∞–∫–æ–Ω—ã** | –î–µ –ú–æ—Ä–≥–∞–Ω | –£–ø—Ä–æ—â–µ–Ω–∏–µ —É—Å–ª–æ–≤–∏–π |

> [!TIP]
> –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `map[T]struct{}` –≤–º–µ—Å—Ç–æ `map[T]bool` –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏ (struct{} –∑–∞–Ω–∏–º–∞–µ—Ç 0 –±–∞–π—Ç)!
