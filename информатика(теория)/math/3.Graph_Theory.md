# ðŸ•¸ Graph Theory (Ð¢ÐµÐ¾Ñ€Ð¸Ñ Ð³Ñ€Ð°Ñ„Ð¾Ð²)

## ðŸ“‘ Ð¡Ð¾Ð´ÐµÑ€Ð¶Ð°Ð½Ð¸Ðµ
1. [Ð§Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ Ð³Ñ€Ð°Ñ„?](#1-Ñ‡Ñ‚Ð¾-Ñ‚Ð°ÐºÐ¾Ðµ-Ð³Ñ€Ð°Ñ„)
2. [Ð’Ð¸Ð´Ñ‹ Ð³Ñ€Ð°Ñ„Ð¾Ð²](#2-Ð²Ð¸Ð´Ñ‹-Ð³Ñ€Ð°Ñ„Ð¾Ð²)
3. [ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð³Ñ€Ð°Ñ„Ð¾Ð² Ð² ÐºÐ¾Ð´Ðµ](#3-Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ-Ð³Ñ€Ð°Ñ„Ð¾Ð²-Ð²-ÐºÐ¾Ð´Ðµ)
4. [ÐžÐ±Ñ…Ð¾Ð´Ñ‹ (BFS, DFS)](#4-Ð¾Ð±Ñ…Ð¾Ð´Ñ‹-bfs-dfs)
5. [ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ](#5-Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ)

---

## 1. ðŸ“ Ð§Ñ‚Ð¾ Ñ‚Ð°ÐºÐ¾Ðµ Ð³Ñ€Ð°Ñ„?

**Ð“Ñ€Ð°Ñ„** â€” ÑÑ‚Ð¾ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…, ÑÐ¾ÑÑ‚Ð¾ÑÑ‰Ð°Ñ Ð¸Ð· **Ð²ÐµÑ€ÑˆÐ¸Ð½** (nodes/vertices) Ð¸ **Ñ€ÐµÐ±ÐµÑ€** (edges), ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¸Ñ… ÑÐ¾ÐµÐ´Ð¸Ð½ÑÑŽÑ‚.

**ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ Ð¸Ð· Ð¶Ð¸Ð·Ð½Ð¸:**
- Ð¡Ð¾Ñ†Ð¸Ð°Ð»ÑŒÐ½Ð°Ñ ÑÐµÑ‚ÑŒ: Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ = Ð»ÑŽÐ´Ð¸, Ñ€ÐµÐ±Ñ€Ð° = Ð´Ñ€ÑƒÐ¶Ð±Ð°
- ÐšÐ°Ñ€Ñ‚Ð°: Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ = Ð³Ð¾Ñ€Ð¾Ð´Ð°, Ñ€ÐµÐ±Ñ€Ð° = Ð´Ð¾Ñ€Ð¾Ð³Ð¸
- Ð˜Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚: Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ = ÑÐ°Ð¹Ñ‚Ñ‹, Ñ€ÐµÐ±Ñ€Ð° = ÑÑÑ‹Ð»ÐºÐ¸

```mermaid
flowchart LR
    A((A)) --- B((B))
    A --- C((C))
    B --- D((D))
    C --- D
    D --- E((E))
```

---

## 2. ðŸ—‚ Ð’Ð¸Ð´Ñ‹ Ð³Ñ€Ð°Ñ„Ð¾Ð²

### ÐŸÐ¾ Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸

- **ÐÐµÐ¾Ñ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ð³Ñ€Ð°Ñ„**: Ð ÐµÐ±Ñ€Ð° Ð±ÐµÐ· Ð½Ð°Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ (Ð´Ñ€ÑƒÐ¶Ð±Ð° â€” Ð²Ð·Ð°Ð¸Ð¼Ð½Ð°Ñ)
- **ÐžÑ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ (Directed)**: Ð¡Ñ‚Ñ€ÐµÐ»Ð¾Ñ‡ÐºÐ¸ Ð² Ð¾Ð´Ð½Ñƒ ÑÑ‚Ð¾Ñ€Ð¾Ð½Ñƒ (Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ° Ð² Twitter â€” Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¾Ñ€Ð¾Ð½Ð½ÑÑ)

```mermaid
flowchart LR
    subgraph ÐÐµÐ¾Ñ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹
        A1((A)) --- B1((B))
        B1 --- C1((C))
    end
    
    subgraph ÐžÑ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹
        A2((A)) --> B2((B))
        B2 --> C2((C))
        C2 --> A2
    end
```

### ÐŸÐ¾ Ð½Ð°Ð»Ð¸Ñ‡Ð¸ÑŽ Ð²ÐµÑÐ¾Ð²

- **Ð’Ð·Ð²ÐµÑˆÐµÐ½Ð½Ñ‹Ð¹ (Weighted)**: Ð£ Ñ€ÐµÐ±ÐµÑ€ ÐµÑÑ‚ÑŒ Ð²ÐµÑ (Ñ€Ð°ÑÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð² ÐºÐ¼, ÑÑ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ)
- **ÐÐµÐ²Ð·Ð²ÐµÑˆÐµÐ½Ð½Ñ‹Ð¹**: Ð’ÑÐµ Ñ€ÐµÐ±Ñ€Ð° Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ñ‹Ðµ

### ÐŸÐ¾ ÑÐ²ÑÐ·Ð½Ð¾ÑÑ‚Ð¸

- **Ð¡Ð²ÑÐ·Ð½Ñ‹Ð¹**: ÐœÐ¾Ð¶Ð½Ð¾ Ð´Ð¾Ð¹Ñ‚Ð¸ Ð¾Ñ‚ Ð»ÑŽÐ±Ð¾Ð¹ Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ Ðº Ð»ÑŽÐ±Ð¾Ð¹ Ð´Ñ€ÑƒÐ³Ð¾Ð¹
- **ÐÐµÑÐ²ÑÐ·Ð½Ñ‹Ð¹**: Ð•ÑÑ‚ÑŒ Ð¸Ð·Ð¾Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚Ñ‹

---

## 3. ðŸ’¾ ÐŸÑ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð³Ñ€Ð°Ñ„Ð¾Ð² Ð² ÐºÐ¾Ð´Ðµ

Ð•ÑÑ‚ÑŒ Ð´Ð²Ð° Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ñ… ÑÐ¿Ð¾ÑÐ¾Ð±Ð°:

### 1. Ð¡Ð¿Ð¸ÑÐ¾Ðº ÑÐ¼ÐµÐ¶Ð½Ð¾ÑÑ‚Ð¸ (Adjacency List) â€” Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÑ‚ÑÑ âœ…

Ð”Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ Ñ…Ñ€Ð°Ð½Ð¸Ð¼ ÑÐ¿Ð¸ÑÐ¾Ðº ÐµÐµ ÑÐ¾ÑÐµÐ´ÐµÐ¹.

```go
type Graph struct {
    adjacencyList map[int][]int
}

func NewGraph() *Graph {
    return &Graph{
        adjacencyList: make(map[int][]int),
    }
}

func (g *Graph) AddEdge(from, to int) {
    g.adjacencyList[from] = append(g.adjacencyList[from], to)
    // Ð”Ð»Ñ Ð½ÐµÐ¾Ñ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð³Ñ€Ð°Ñ„Ð° Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾Ðµ Ñ€ÐµÐ±Ñ€Ð¾
    g.adjacencyList[to] = append(g.adjacencyList[to], from)
}

// ÐŸÑ€Ð¸Ð¼ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ
func main() {
    graph := NewGraph()
    graph.AddEdge(1, 2)
    graph.AddEdge(1, 3)
    graph.AddEdge(2, 4)
    
    // adjacencyList:
    // 1 -> [2, 3]
    // 2 -> [1, 4]
    // 3 -> [1]
    // 4 -> [2]
}
```

**ÐŸÐ»ÑŽÑÑ‹:**
- Ð­ÐºÐ¾Ð½Ð¾Ð¼Ð¸Ñ‚ Ð¿Ð°Ð¼ÑÑ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°Ð·Ñ€ÐµÐ¶ÐµÐ½Ð½Ñ‹Ñ… Ð³Ñ€Ð°Ñ„Ð¾Ð² (Ð¼Ð°Ð»Ð¾ Ñ€ÐµÐ±ÐµÑ€)
- Ð‘Ñ‹ÑÑ‚Ñ€Ð¾ Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ ÑÐ¾ÑÐµÐ´ÐµÐ¹ Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹

**ÐœÐ¸Ð½ÑƒÑÑ‹:**
- ÐœÐµÐ´Ð»ÐµÐ½Ð½Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÑ‚ÑŒ, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ñ€ÐµÐ±Ñ€Ð¾ Ð¼ÐµÐ¶Ð´Ñƒ Ð´Ð²ÑƒÐ¼Ñ Ð²ÐµÑ€ÑˆÐ¸Ð½Ð°Ð¼Ð¸: O(degree)

---

### 2. ÐœÐ°Ñ‚Ñ€Ð¸Ñ†Ð° ÑÐ¼ÐµÐ¶Ð½Ð¾ÑÑ‚Ð¸ (Adjacency Matrix)

2D Ð¼Ð°ÑÑÐ¸Ð², Ð³Ð´Ðµ `matrix[i][j] = 1`, ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ñ€ÐµÐ±Ñ€Ð¾ Ð¸Ð· i Ð² j.

```go
type GraphMatrix struct {
    matrix [][]int
    size   int
}

func NewGraphMatrix(size int) *GraphMatrix {
    matrix := make([][]int, size)
    for i := range matrix {
        matrix[i] = make([]int, size)
    }
    return &GraphMatrix{
        matrix: matrix,
        size:   size,
    }
}

func (g *GraphMatrix) AddEdge(from, to int) {
    g.matrix[from][to] = 1
    g.matrix[to][from] = 1 // Ð”Ð»Ñ Ð½ÐµÐ¾Ñ€Ð¸ÐµÐ½Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾
}

func (g *GraphMatrix) HasEdge(from, to int) bool {
    return g.matrix[from][to] == 1
}
```

**ÐŸÐ»ÑŽÑÑ‹:**
- ÐžÑ‡ÐµÐ½ÑŒ Ð±Ñ‹ÑÑ‚Ñ€Ð¾ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ñ€ÐµÐ±Ñ€Ð°: O(1)

**ÐœÐ¸Ð½ÑƒÑÑ‹:**
- Ð’ÑÐµÐ³Ð´Ð° Ð·Ð°Ð½Ð¸Ð¼Ð°ÐµÑ‚ O(VÂ²) Ð¿Ð°Ð¼ÑÑ‚Ð¸, Ð´Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ñ€ÐµÐ±ÐµÑ€ Ð¼Ð°Ð»Ð¾

---

## 4. ðŸš¶â€â™‚ï¸ ÐžÐ±Ñ…Ð¾Ð´Ñ‹ (BFS, DFS)

### BFS (Breadth-First Search) â€” ÐŸÐ¾Ð¸ÑÐº Ð² ÑˆÐ¸Ñ€Ð¸Ð½Ñƒ

Ð˜Ð´ÐµÐ¼ Ð¿Ð¾ Ð³Ñ€Ð°Ñ„Ñƒ **ÑÐ»Ð¾ÑÐ¼Ð¸**: ÑÐ½Ð°Ñ‡Ð°Ð»Ð° Ð²ÑÐµ ÑÐ¾ÑÐµÐ´Ð¸, Ð¿Ð¾Ñ‚Ð¾Ð¼ ÑÐ¾ÑÐµÐ´Ð¸ ÑÐ¾ÑÐµÐ´ÐµÐ¹.

**Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ (Queue)**.

```go
func BFS(graph *Graph, start int) {
    visited := make(map[int]bool)
    queue := []int{start}
    visited[start] = true
    
    for len(queue) > 0 {
        // Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚
        node := queue[0]
        queue = queue[1:]
        
        fmt.Println("ÐŸÐ¾ÑÐµÑ‰Ð°ÐµÐ¼:", node)
        
        // Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð²ÑÐµÑ… ÑÐ¾ÑÐµÐ´ÐµÐ¹ Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´ÑŒ
        for _, neighbor := range graph.adjacencyList[node] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
}
```

**ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ:**
- ÐŸÐ¾Ð¸ÑÐº ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐµÐ³Ð¾ Ð¿ÑƒÑ‚Ð¸ (Ð² Ð½ÐµÐ²Ð·Ð²ÐµÑˆÐµÐ½Ð½Ð¾Ð¼ Ð³Ñ€Ð°Ñ„Ðµ)
- ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ²ÑÐ·Ð½Ð¾ÑÑ‚Ð¸ Ð³Ñ€Ð°Ñ„Ð°
- ÐŸÐ¾Ð¸ÑÐº ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ ÑÐ²ÑÐ·Ð½Ð¾ÑÑ‚Ð¸

**Ð¡Ð»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ:** O(V + E) Ð³Ð´Ðµ V = Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹, E = Ñ€ÐµÐ±Ñ€Ð°

---

### DFS (Depth-First Search) â€” ÐŸÐ¾Ð¸ÑÐº Ð² Ð³Ð»ÑƒÐ±Ð¸Ð½Ñƒ

Ð˜Ð´ÐµÐ¼ **Ð´Ð¾ ÑƒÐ¿Ð¾Ñ€Ð°** Ð¿Ð¾ Ð¾Ð´Ð½Ð¾Ð¼Ñƒ Ð¿ÑƒÑ‚Ð¸, Ð¿Ð¾Ñ‚Ð¾Ð¼ Ð¾Ñ‚ÐºÐ°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ÑÑ Ð¸ Ð¿Ñ€Ð¾Ð±ÑƒÐµÐ¼ Ð´Ñ€ÑƒÐ³Ð¸Ðµ.

**Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ ÑÑ‚ÐµÐº (Stack) Ð¸Ð»Ð¸ Ñ€ÐµÐºÑƒÑ€ÑÐ¸ÑŽ**.

```go
func DFS(graph *Graph, start int, visited map[int]bool) {
    if visited == nil {
        visited = make(map[int]bool)
    }
    
    visited[start] = true
    fmt.Println("ÐŸÐ¾ÑÐµÑ‰Ð°ÐµÐ¼:", start)
    
    for _, neighbor := range graph.adjacencyList[start] {
        if !visited[neighbor] {
            DFS(graph, neighbor, visited)
        }
    }
}

// Ð˜Ñ‚ÐµÑ€Ð°Ñ‚Ð¸Ð²Ð½Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ (Ñ ÑÐ²Ð½Ñ‹Ð¼ ÑÑ‚ÐµÐºÐ¾Ð¼)
func DFSIterative(graph *Graph, start int) {
    visited := make(map[int]bool)
    stack := []int{start}
    
    for len(stack) > 0 {
        // Ð˜Ð·Ð²Ð»ÐµÐºÐ°ÐµÐ¼ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        
        if visited[node] {
            continue
        }
        
        visited[node] = true
        fmt.Println("ÐŸÐ¾ÑÐµÑ‰Ð°ÐµÐ¼:", node)
        
        for _, neighbor := range graph.adjacencyList[node] {
            if !visited[neighbor] {
                stack = append(stack, neighbor)
            }
        }
    }
}
```

**ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ:**
- ÐŸÐ¾Ð¸ÑÐº Ñ†Ð¸ÐºÐ»Ð¾Ð²
- Ð¢Ð¾Ð¿Ð¾Ð»Ð¾Ð³Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ°
- ÐŸÐ¾Ð¸ÑÐº ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½Ñ‚ ÑÐ¸Ð»ÑŒÐ½Ð¾Ð¹ ÑÐ²ÑÐ·Ð½Ð¾ÑÑ‚Ð¸
- Ð ÐµÑˆÐµÐ½Ð¸Ðµ Ð»Ð°Ð±Ð¸Ñ€Ð¸Ð½Ñ‚Ð¾Ð²

**Ð¡Ð»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ:** O(V + E)

---

### Ð¡Ñ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ BFS Ð¸ DFS

| Ð¥Ð°Ñ€Ð°ÐºÑ‚ÐµÑ€Ð¸ÑÑ‚Ð¸ÐºÐ° | BFS | DFS |
|:---|:---|:---|
| **Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ…** | ÐžÑ‡ÐµÑ€ÐµÐ´ÑŒ (Queue) | Ð¡Ñ‚ÐµÐº (Stack) / Ð ÐµÐºÑƒÑ€ÑÐ¸Ñ |
| **ÐŸÐ¾Ñ€ÑÐ´Ð¾Ðº Ð¾Ð±Ñ…Ð¾Ð´Ð°** | ÐŸÐ¾ ÑƒÑ€Ð¾Ð²Ð½ÑÐ¼ (ÑÐ»Ð¾ÑÐ¼) | Ð”Ð¾ ÑƒÐ¿Ð¾Ñ€Ð° Ð¿Ð¾ Ð¿ÑƒÑ‚Ð¸ |
| **ÐšÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ** | âœ… ÐÐ°Ñ…Ð¾Ð´Ð¸Ñ‚ | âŒ ÐÐµ Ð³Ð°Ñ€Ð°Ð½Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ |
| **ÐŸÐ°Ð¼ÑÑ‚ÑŒ** | O(V) | O(h) Ð³Ð´Ðµ h = Ð³Ð»ÑƒÐ±Ð¸Ð½Ð° |
| **ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ** | ÐšÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ, ÑƒÑ€Ð¾Ð²Ð½Ð¸ | Ð¦Ð¸ÐºÐ»Ñ‹, Ñ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð³Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ° |

---

## 5. ðŸŽ¯ ÐŸÑ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ

### Ð¡Ð¾Ñ†Ð¸Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐµÑ‚Ð¸

```go
// ÐÐ°Ð¹Ñ‚Ð¸ Ð²ÑÐµÑ… Ð´Ñ€ÑƒÐ·ÐµÐ¹ Ð½Ð° Ñ€Ð°ÑÑÑ‚Ð¾ÑÐ½Ð¸Ð¸ 2 ÑˆÐ°Ð³Ð¾Ð²
func findFriendsOfFriends(graph *Graph, userID int) []int {
    friends := make(map[int]bool)
    visited := make(map[int]bool)
    queue := []int{userID}
    visited[userID] = true
    level := 0
    
    for len(queue) > 0 && level < 2 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            
            for _, neighbor := range graph.adjacencyList[node] {
                if !visited[neighbor] {
                    visited[neighbor] = true
                    queue = append(queue, neighbor)
                    if level == 1 {
                        friends[neighbor] = true
                    }
                }
            }
        }
        level++
    }
    
    result := []int{}
    for friend := range friends {
        result = append(result, friend)
    }
    return result
}
```

### ÐÐ°Ð²Ð¸Ð³Ð°Ñ†Ð¸Ñ (ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ)

BFS Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ Ð² Ð½ÐµÐ²Ð·Ð²ÐµÑˆÐµÐ½Ð½Ð¾Ð¼ Ð³Ñ€Ð°Ñ„Ðµ.

### Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹

Ð“Ñ€Ð°Ñ„ Ñ Ð²ÐµÑ€ÑˆÐ¸Ð½Ð°Ð¼Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¸ Ñ‚Ð¾Ð²Ð°Ñ€Ð¾Ð², Ñ€ÐµÐ±Ñ€Ð° = "ÐºÑƒÐ¿Ð¸Ð» Ñ‚Ð¾Ð²Ð°Ñ€".

---

## ðŸ’¡ Ð˜Ñ‚Ð¾Ð³

- **Ð“Ñ€Ð°Ñ„** = Ð²ÐµÑ€ÑˆÐ¸Ð½Ñ‹ + Ñ€ÐµÐ±Ñ€Ð°
- **Adjacency List** â€” Ð»ÑƒÑ‡ÑˆÐµ Ð´Ð»Ñ Ñ€Ð°Ð·Ñ€ÐµÐ¶ÐµÐ½Ð½Ñ‹Ñ… Ð³Ñ€Ð°Ñ„Ð¾Ð²
- **BFS** â€” ÐºÑ€Ð°Ñ‚Ñ‡Ð°Ð¹ÑˆÐ¸Ð¹ Ð¿ÑƒÑ‚ÑŒ, Ð¾Ð±Ñ…Ð¾Ð´ Ð¿Ð¾ ÑƒÑ€Ð¾Ð²Ð½ÑÐ¼
- **DFS** â€” Ñ†Ð¸ÐºÐ»Ñ‹, Ñ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð³Ð¸Ñ‡ÐµÑÐºÐ°Ñ ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ°, Ð¾Ð±Ñ…Ð¾Ð´ Ð´Ð¾ ÑƒÐ¿Ð¾Ñ€Ð°
