# ๐ธ๏ธ GraphQL: ะฏะทัะบ ะทะฐะฟัะพัะพะฒ ะฝะพะฒะพะณะพ ะฟะพะบะพะปะตะฝะธั

## ๐ ะกะพะดะตัะถะฐะฝะธะต
1. [ะคะธะปะพัะพัะธั GraphQL](#ัะธะปะพัะพัะธั)
2. [ะขะธะฟะพะฒะฐั ะกัะตะผะฐ (Schema)](#ััะตะผะฐ)
3. [ะะฟะตัะฐัะธะธ: Query, Mutation, Subscription](#ะพะฟะตัะฐัะธะธ)
4. [ะะตะทะพะปะฒะตัั (Resolvers)](#ัะตะทะพะปะฒะตัั)
5. [ะัะพะฑะปะตะผะฐ N+1 ะธ DataLoader](#ะฟัะพะฑะปะตะผะฐ-n1-ะธ-dataloader)
6. [ะัะพะฑะปะตะผั REST, ะบะพัะพััะต ัะตัะฐะตั GraphQL](#ะฟัะพะฑะปะตะผั-rest)
7. [Pagination (ะะฐะณะธะฝะฐัะธั)](#pagination)
8. [ะะฑัะฐะฑะพัะบะฐ ะพัะธะฑะพะบ](#ะพะฑัะฐะฑะพัะบะฐ-ะพัะธะฑะพะบ)
9. [ะะตะทะพะฟะฐัะฝะพััั](#ะฑะตะทะพะฟะฐัะฝะพััั)
10. [ะััะธัะพะฒะฐะฝะธะต](#ะบััะธัะพะฒะฐะฝะธะต)
11. [ะะตะฐะปะธะทะฐัะธั ะฝะฐ Go ั gqlgen](#ัะตะฐะปะธะทะฐัะธั-ะฝะฐ-go-ั-gqlgen)
12. [ะะพะณะดะฐ ะะ ััะพะธั ะธัะฟะพะปัะทะพะฒะฐัั](#ะผะธะฝััั)

---

## ๐งญ ะคะธะปะพัะพัะธั

**GraphQL** โ ััะพ ะฝะต ะฑะฐะทะฐ ะดะฐะฝะฝัั ะธ ะฝะต ะทะฐะผะตะฝะฐ REST. ะญัะพ **ัะทัะบ ะทะฐะฟัะพัะพะฒ** ะธ ัะปะพะน ะผะตะถะดั ะบะปะธะตะฝัะพะผ ะธ ะธััะพัะฝะธะบะฐะผะธ ะดะฐะฝะฝัั. ะะปะฐะฒะฝะฐั ะธะดะตั: **"ะะปะธะตะฝั ะทะฐะบะฐะทัะฒะฐะตั ัะพะปัะบะพ ัะพ, ััะพ ะตะผั ะฝัะถะฝะพ"**.

### ะะปััะตะฒัะต ะพัะปะธัะธั ะพั REST:

| ะฅะฐัะฐะบัะตัะธััะธะบะฐ | REST | GraphQL |
|:---|:---|:---|
| **Endpoints** | ะะฝะพะณะพ (`/users`, `/posts`) | ะะดะธะฝ (`/graphql`) |
| **ะกัััะบัััะฐ ะพัะฒะตัะฐ** | ะะฟัะตะดะตะปัะตั ัะตัะฒะตั | ะะฟัะตะดะตะปัะตั ะบะปะธะตะฝั |
| **Overfetching** | ะงะฐััะฐั ะฟัะพะฑะปะตะผะฐ | ะะตั |
| **Underfetching** | ะะฝะพะถะตััะฒะพ ะทะฐะฟัะพัะพะฒ | ะะดะธะฝ ะทะฐะฟัะพั |
| **ะะตััะธะพะฝะธัะพะฒะฐะฝะธะต** | `/v1/`, `/v2/` | ะะตั ะฝัะถะดั (deprecation) |

> [!NOTE]
> ะ ะพัะปะธัะธะต ะพั REST, ะณะดะต ััััะบัััะฐ ะพัะฒะตัะฐ ะพะฟัะตะดะตะปัะตััั ัะตัะฒะตัะพะผ, ะฒ GraphQL ััััะบัััั ะพะฟัะตะดะตะปัะตั **ะบะปะธะตะฝั**.

---

## ๐ ะกัะตะผะฐ (Schema)

ะัะต ะดะฐะฝะฝัะต ะฒ GraphQL ัััะพะณะพ ัะธะฟะธะทะธัะพะฒะฐะฝั. ะกัะตะผะฐ โ ััะพ ะบะพะฝััะฐะบั ะผะตะถะดั ะบะปะธะตะฝัะพะผ ะธ ัะตัะฒะตัะพะผ.

### ะะฐะทะพะฒัะต ัะธะฟั

```graphql
# ะกะบะฐะปััะฝัะต ัะธะฟั
type User {
  id: ID!           # ! = ะพะฑัะทะฐัะตะปัะฝะพะต ะฟะพะปะต
  username: String!
  email: String
  age: Int
  rating: Float
  isActive: Boolean!
}

# Enum
enum UserRole {
  ADMIN
  MODERATOR
  USER
}

# ะกะฒัะทะธ ะผะตะถะดั ัะธะฟะฐะผะธ
type Post {
  id: ID!
  title: String!
  content: String!
  author: User!        # ะะดะธะฝ-ะบ-ะพะดะฝะพะผั
  comments: [Comment!]! # ะะดะธะฝ-ะบะพ-ะผะฝะพะณะธะผ
}

type Comment {
  id: ID!
  text: String!
  post: Post!
  author: User!
}

# Input type ะดะปั ะผััะฐัะธะน
input CreateUserInput {
  username: String!
  email: String!
  password: String!
}

# ะะฝัะตััะตะนัั
interface Node {
  id: ID!
  createdAt: String!
}

type User implements Node {
  id: ID!
  createdAt: String!
  username: String!
}

# Union types
union SearchResult = User | Post | Comment

# Custom scalars
scalar DateTime
scalar JSON
```

---

## ๐ง ะะฟะตัะฐัะธะธ: Query, Mutation, Subscription

### 1. Query (ะงัะตะฝะธะต ะดะฐะฝะฝัั)

```graphql
type Query {
  # ะะพะปััะธัั ะพะดะฝะพะณะพ ะฟะพะปัะทะพะฒะฐัะตะปั
  user(id: ID!): User
  
  # ะะพะปััะธัั ัะฟะธัะพะบ
  users(
    limit: Int = 10
    offset: Int = 0
    filter: UserFilter
  ): [User!]!
  
  # ะะพะธัะบ
  search(query: String!): [SearchResult!]!
  
  # ะะฝะต ัะฐะผะพะผั
  me: User
}

input UserFilter {
  role: UserRole
  isActive: Boolean
  minAge: Int
}
```

**ะัะธะผะตั ะทะฐะฟัะพัะฐ ะบะปะธะตะฝัะฐ:**

```graphql
# ะขะพัะฝะพ ัะบะฐะทัะฒะฐะตะผ, ะบะฐะบะธะต ะฟะพะปั ะฝัะถะฝั
query GetUserProfile {
  user(id: "123") {
    id
    username
    email
    posts {
      id
      title
      comments {
        id
        text
      }
    }
  }
}
```

**ะะปะธะฐัั ะธ ััะฐะณะผะตะฝัั:**

```graphql
query {
  # ะะปะธะฐัั ะฟะพะทะฒะพะปััั ะดะตะปะฐัั ะฝะตัะบะพะปัะบะพ ะทะฐะฟัะพัะพะฒ ะพะดะฝะพะณะพ ัะธะฟะฐ
  admin: user(id: "1") {
    ...UserFields
  }
  
  currentUser: user(id: "123") {
    ...UserFields
  }
}

# Fragment ะดะปั ะฟะตัะตะธัะฟะพะปัะทะพะฒะฐะฝะธั
fragment UserFields on User {
  id
  username
  email
  posts {
    title
  }
}
```

---

### 2. Mutation (ะะทะผะตะฝะตะฝะธะต ะดะฐะฝะฝัั)

```graphql
type Mutation {
  # Create
  createUser(input: CreateUserInput!): User!
  
  # Update
  updateUser(id: ID!, input: UpdateUserInput!): User!
  
  # Delete
  deleteUser(id: ID!): Boolean!
  
  # ะกะปะพะถะฝะฐั ะพะฟะตัะฐัะธั
  publishPost(id: ID!): Post!
}

input UpdateUserInput {
  username: String
  email: String
  # ะัะต ะฟะพะปั optional ะดะปั partial update
}
```

**ะัะธะผะตั ะผััะฐัะธะธ:**

```graphql
mutation CreateNewUser {
  createUser(input: {
    username: "john_doe"
    email: "john@example.com"
    password: "secret123"
  }) {
    id
    username
    createdAt
  }
}
```

---

### 3. Subscription (Real-time ะพะฑะฝะพะฒะปะตะฝะธั)

ะะปั WebSocket ัะพะตะดะธะฝะตะฝะธะน, ะบะพะณะดะฐ ะฝัะถะฝะพ ะฟะพะปััะฐัั ะพะฑะฝะพะฒะปะตะฝะธั ะฒ ัะตะฐะปัะฝะพะผ ะฒัะตะผะตะฝะธ.

```graphql
type Subscription {
  # ะะพะดะฟะธัะบะฐ ะฝะฐ ะฝะพะฒัะต ัะพะพะฑัะตะฝะธั ะฒ ัะฐัะต
  messageAdded(chatId: ID!): Message!
  
  # ะะพะดะฟะธัะบะฐ ะฝะฐ ะธะทะผะตะฝะตะฝะธั ะฟะพะปัะทะพะฒะฐัะตะปั
  userUpdated(userId: ID!): User!
  
  # ะะพะดะฟะธัะบะฐ ะฝะฐ ััะตััะธะบ ะพะฝะปะฐะนะฝ
  onlineCount: Int!
}
```

**ะัะธะผะตั ะธัะฟะพะปัะทะพะฒะฐะฝะธั:**

```graphql
subscription OnMessageAdded {
  messageAdded(chatId: "room-1") {
    id
    text
    author {
      username
    }
    createdAt
  }
}
```

```mermaid
sequenceDiagram
    participant C as Client
    participant WS as WebSocket
    participant GQL as GraphQL Server
    participant DB as Database
    
    C->>WS: Subscribe: messageAdded(chatId: "room-1")
    WS->>GQL: Establish subscription
    
    Note over DB: ะะพะฒะพะต ัะพะพะฑัะตะฝะธะต
    DB->>GQL: Trigger event
    GQL->>WS: Push update
    WS->>C: {messageAdded: {...}}
    
    Note over C: ะะฒัะพะผะฐัะธัะตัะบะพะต ะพะฑะฝะพะฒะปะตะฝะธะต UI
```

---

## โ๏ธ ะะตะทะพะปะฒะตัั (Resolvers)

ะะตะทะพะปะฒะตั โ ััะพ ััะฝะบัะธั, ะบะพัะพัะฐั ะทะฝะฐะตั, **ะบะฐะบ ะฟะพะปััะธัั ะดะฐะฝะฝัะต** ะดะปั ะบะพะฝะบัะตัะฝะพะณะพ ะฟะพะปั.

### ะกัััะบัััะฐ ัะตะทะพะปะฒะตัะพะฒ

```go
type Resolver struct {
    db *sql.DB
    cache *redis.Client
    userService *UserService
}

// Query ัะตะทะพะปะฒะตัั
func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) {
    // ะะพะณะธะบะฐ ะฟะพะปััะตะฝะธั ะฟะพะปัะทะพะฒะฐัะตะปั
    return r.userService.GetByID(ctx, id)
}

// Field ัะตะทะพะปะฒะตั (ะดะปั ะฒะปะพะถะตะฝะฝัั ะฟะพะปะตะน)
func (r *UserResolver) Posts(ctx context.Context, user *model.User) ([]*model.Post, error) {
    return r.db.GetPostsByUserID(ctx, user.ID)
}
```

```mermaid
flowchart TD
    Query[Query: user id: 123] --> UserResolver[User Resolver]
    UserResolver --> DB1[(PostgreSQL)]
    DB1 --> UserData[User Data]
    
    UserData --> PostsResolver[Posts Field Resolver]
    PostsResolver --> DB2[(Posts DB)]
    DB2 --> PostsData[Posts Data]
    
    PostsData --> AuthorResolver[Author Field Resolver]
    AuthorResolver --> Cache[(Redis Cache)]
    Cache --> FinalResponse[Response to Client]
```

> [!NOTE]
> **ะะปะฐะฒะฝะฐั ัะธัะฐ**: ะะตะทะพะปะฒะตัั ะผะพะณัั ะฑัะฐัั ะดะฐะฝะฝัะต ะธะท ัะฐะทะฝัั ะธััะพัะฝะธะบะพะฒ
> - User โ PostgreSQL
> - Posts โ MongoDB
> - Avatar โ S3
> - Comments โ Microservice
>
> ะะปั ะบะปะธะตะฝัะฐ ััะพ ะฒัะณะปัะดะธั ะบะฐะบ **ะพะดะธะฝ ะทะฐะฟัะพั**.

---

## ๐ฅ ะัะพะฑะปะตะผะฐ N+1 ะธ DataLoader

### ะัะพะฑะปะตะผะฐ N+1

ะกะฐะผะฐั ัะฐััะฐั ะฟัะพะฑะปะตะผะฐ ะฟัะพะธะทะฒะพะดะธัะตะปัะฝะพััะธ ะฒ GraphQL.

**ะะฐะฟัะพั:**
```graphql
query {
  posts {         # 1 ะทะฐะฟัะพั ะฒ ะะ โ 10 ะฟะพััะพะฒ
    title
    author {      # 10 ะทะฐะฟัะพัะพะฒ ะฒ ะะ (ะดะปั ะบะฐะถะดะพะณะพ ะฟะพััะฐ!)
      username
    }
  }
}
```

**ะะฐะธะฒะฝะฐั ัะตะฐะปะธะทะฐัะธั:**
```go
func (r *PostResolver) Author(ctx context.Context, post *model.Post) (*model.User, error) {
    // โ ะัะทัะฒะฐะตััั 10 ัะฐะท!
    return r.db.GetUserByID(ctx, post.AuthorID)
}
```

ะะตะทัะปััะฐั: **1 + 10 = 11 ะทะฐะฟัะพัะพะฒ** ะฒะผะตััะพ **2**.

---

### ะะตัะตะฝะธะต: DataLoader

DataLoader ะณััะฟะฟะธััะตั ะทะฐะฟัะพัั ะธ ะฒัะฟะพะปะฝัะตั ะธั ะฑะฐััะตะผ.

**ะฃััะฐะฝะพะฒะบะฐ:**
```bash
go get github.com/graph-gophers/dataloader
```

**ะะตะฐะปะธะทะฐัะธั:**
```go
type Loaders struct {
    UserLoader *dataloader.Loader
}

func NewLoaders(db *sql.DB) *Loaders {
    userBatchFn := func(ctx context.Context, keys dataloader.Keys) []*dataloader.Result {
        // ะัะตะพะฑัะฐะทัะตะผ keys ะฒ IDs
        ids := make([]string, len(keys))
        for i, key := range keys {
            ids[i] = key.String()
        }
        
        // ๐ ะะะะ ะทะฐะฟัะพั ะฒะผะตััะพ N!
        users, err := db.GetUsersByIDs(ctx, ids)
        
        // ะกะพะทะดะฐะตะผ map ะดะปั ะฑััััะพะณะพ ะดะพัััะฟะฐ
        userMap := make(map[string]*User)
        for _, user := range users {
            userMap[user.ID] = user
        }
        
        // ะะพะทะฒัะฐัะฐะตะผ ะฒ ัะพะผ ะถะต ะฟะพััะดะบะต, ััะพ ะธ keys
        results := make([]*dataloader.Result, len(keys))
        for i, key := range keys {
            user, ok := userMap[key.String()]
            if ok {
                results[i] = &dataloader.Result{Data: user}
            } else {
                results[i] = &dataloader.Result{Error: fmt.Errorf("user not found")}
            }
        }
        
        return results
    }
    
    return &Loaders{
        UserLoader: dataloader.NewBatchedLoader(userBatchFn),
    }
}

// ะัะฟะพะปัะทะพะฒะฐะฝะธะต ะฒ ัะตะทะพะปะฒะตัะต
func (r *PostResolver) Author(ctx context.Context, post *model.Post) (*model.User, error) {
    loaders := ctx.Value("loaders").(*Loaders)
    
    thunk := loaders.UserLoader.Load(ctx, dataloader.StringKey(post.AuthorID))
    result, err := thunk()
    if err != nil {
        return nil, err
    }
    
    return result.(*model.User), nil
}
```

**ะะตะทัะปััะฐั**: ะัะต 10 ะทะฐะฟัะพัะพะฒ ะณััะฟะฟะธัััััั ะธ ะฒัะฟะพะปะฝััััั **ะพะดะฝะธะผ ะฑะฐััะตะผ**!

```mermaid
sequenceDiagram
    participant GQL as GraphQL
    participant DL as DataLoader
    participant DB as Database
    
    Note over GQL: posts { author { username } }
    
    GQL->>DL: Load(userID: 1)
    GQL->>DL: Load(userID: 2)
    GQL->>DL: Load(userID: 3)
    Note over DL: ะะฐะบะฐะฟะปะธะฒะฐะตั ะฒ ัะตัะตะฝะธะต tick
    
    DL->>DB: SELECT * FROM users WHERE id IN (1,2,3)
    DB->>DL: [user1, user2, user3]
    
    DL->>GQL: user1
    DL->>GQL: user2
    DL->>GQL: user3
```

---

## ๐ ะัะพะฑะปะตะผั REST, ะบะพัะพััะต ัะตัะฐะตั GraphQL

### 1. Overfetching (ะะทะฑััะพัะฝะพััั)

**REST:**
```bash
GET /users/123
# ะะพะทะฒัะฐัะฐะตั ะะกะ ะฟะพะปั (50+ ะฟะพะปะตะน)
{
  "id": 123,
  "username": "john",
  "email": "john@example.com",
  "bio": "...",
  "location": "...",
  "website": "...",
  "avatar": "...",
  # + ะตัะต 40 ะฟะพะปะตะน, ะบะพัะพััะต ะฝะต ะฝัะถะฝั
}
```

**GraphQL:**
```graphql
query {
  user(id: 123) {
    username  # ะขะพะปัะบะพ ัะพ, ััะพ ะฝัะถะฝะพ
  }
}
```

**ะญะบะพะฝะพะผะธั**: ะะฐ ะผะพะฑะธะปัะฝัั ััััะพะนััะฒะฐั ััะพ ะบัะธัะธัะฝะพ ะดะปั ะฑะฐัะฐัะตะธ ะธ ััะฐัะธะบะฐ!

---

### 2. Underfetching (ะะตะดะพััะฐัะพัะฝะพััั)

**REST** (ะฝัะถะฝะพ 3 ะทะฐะฟัะพัะฐ):
```bash
GET /users/123           # ะัะพัะธะปั
GET /users/123/posts     # ะะพััั
GET /users/123/followers # ะะพะดะฟะธััะธะบะธ
```

**GraphQL** (ะพะดะธะฝ ะทะฐะฟัะพั):
```graphql
query {
  user(id: 123) {
    username
    posts { title }
    followers { username }
  }
}
```

---

### 3. ะะตััะธะพะฝะฝะพััั

**REST**: ะัะธัะพะดะธััั ะฟะปะพะดะธัั `/v1/`, `/v2/`, `/v3/`

**GraphQL**: ะะพะปั ะฟะพะผะตัะฐัััั ะบะฐะบ `deprecated`
```graphql
type User {
  username: String!
  name: String! @deprecated(reason: "Use 'username' instead")
}
```

ะกัะฐััะต ะบะปะธะตะฝัั ะฟัะพะดะพะปะถะฐัั ัะฐะฑะพัะฐัั, ะฝะพะฒัะต ะธัะฟะพะปัะทััั ะฝะพะฒัะต ะฟะพะปั.

---

## ๐ Pagination (ะะฐะณะธะฝะฐัะธั)

### 1. Offset-based

```graphql
type Query {
  users(limit: Int!, offset: Int!): [User!]!
}

# ะัะฟะพะปัะทะพะฒะฐะฝะธะต
query {
  users(limit: 10, offset: 20) {
    username
  }
}
```

**ะัะพะฑะปะตะผะฐ**: ะัะธ ะธะทะผะตะฝะตะฝะธะธ ะดะฐะฝะฝัั ะผะพะถะฝะพ ะฟัะพะฟัััะธัั ะธะปะธ ะดัะฑะปะธัะพะฒะฐัั ะทะฐะฟะธัะธ.

---

### 2. Cursor-based (ัะตะบะพะผะตะฝะดัะตััั)

```graphql
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type Query {
  users(first: Int, after: String): UserConnection!
}
```

**ะัะฟะพะปัะทะพะฒะฐะฝะธะต:**
```graphql
query {
  users(first: 10, after: "cursor123") {
    edges {
      cursor
      node {
        username
      }
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

---

### 3. Relay Cursor Connections (ััะฐะฝะดะฐัั)

```graphql
type Query {
  users(
    first: Int
    after: String
    last: Int
    before: String
  ): UserConnection!
}
```

```mermaid
flowchart LR
    Start[Start] -->|first: 10| Page1[Items 1-10]
    Page1 -->|after: cursor10, first: 10| Page2[Items 11-20]
    Page2 -->|after: cursor20, first: 10| Page3[Items 21-30]
    
    Page3 -->|before: cursor30, last: 10| Page2
    Page2 -->|before: cursor20, last: 10| Page1
```

---

## โ ะะฑัะฐะฑะพัะบะฐ ะพัะธะฑะพะบ

### ะกัััะบัััะฐ ะพัะธะฑะพะบ

GraphQL ะฒะพะทะฒัะฐัะฐะตั **ัะฐััะธัะฝัะต ะดะฐะฝะฝัะต** + ะผะฐััะธะฒ ะพัะธะฑะพะบ.

```json
{
  "data": {
    "user": {
      "username": "john",
      "posts": null  // ะัะธะฑะบะฐ ะทะดะตัั
    }
  },
  "errors": [
    {
      "message": "Failed to fetch posts",
      "path": ["user", "posts"],
      "extensions": {
        "code": "DATABASE_ERROR",
        "timestamp": "2024-01-01T10:00:00Z"
      }
    }
  ]
}
```

### ะขะธะฟั ะพัะธะฑะพะบ ะฒ Go

```go
type ErrorCode string

const (
    ErrorCodeNotFound      ErrorCode = "NOT_FOUND"
    ErrorCodeUnauthorized  ErrorCode = "UNAUTHORIZED"
    ErrorCodeValidation    ErrorCode = "VALIDATION_ERROR"
    ErrorCodeInternal      ErrorCode = "INTERNAL_ERROR"
)

func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) {
    user, err := r.db.GetUser(ctx, id)
    if errors.Is(err, sql.ErrNoRows) {
        return nil, &gqlerror.Error{
            Message: "User not found",
            Extensions: map[string]interface{}{
                "code": ErrorCodeNotFound,
            },
        }
    }
    
    return user, nil
}
```

---

## ๐ ะะตะทะพะฟะฐัะฝะพััั

### 1. Depth Limiting (ะะณัะฐะฝะธัะตะฝะธะต ะณะปัะฑะธะฝั)

ะะฐัะธัะฐ ะพั ะฒะปะพะถะตะฝะฝัั ะทะฐะฟัะพัะพะฒ:
```graphql
# ะัะฐะบะฐ: ะฑะตัะบะพะฝะตัะฝะฐั ะฒะปะพะถะตะฝะฝะพััั
query {
  user {
    posts {
      author {
        posts {
          author {
            posts {
              # ... ะธ ัะฐะบ ะดะพ ะฟะฐะดะตะฝะธั ัะตัะฒะตัะฐ
            }
          }
        }
      }
    }
  }
}
```

**ะะตัะตะฝะธะต ะฒ gqlgen:**
```go
import "github.com/99designs/gqlgen/graphql/handler/extension"

srv := handler.NewDefaultServer(generated.NewExecutableSchema(cfg))
srv.Use(extension.FixedComplexityLimit(100)) // ะะฐะบั ัะปะพะถะฝะพััั
```

---

### 2. Query Cost Analysis

ะะฐะถะดะพะต ะฟะพะปะต ะธะผะตะตั "ััะพะธะผะพััั":
```go
type Post {
  id: Int          // cost: 1
  title: String    // cost: 1
  comments: [Comment]  // cost: 10 (ะดะพัะพะณะฐั ะพะฟะตัะฐัะธั)
}
```

ะะฐะฟัะพั ั `limit: 1000` ะฝะฐ comments = 10,000 ะตะดะธะฝะธั โ ะพัะบะปะพะฝะธัั.

---

### 3. Timeout ะธ Rate Limiting

```go
func (r *Resolver) User(ctx context.Context, id string) (*model.User, error) {
    // ะะพะฝัะตะบัั ั ัะฐะนะผะฐััะพะผ
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    return r.db.GetUser(ctx, id)
}
```

---

## ๐พ ะััะธัะพะฒะฐะฝะธะต

### 1. Automatic Persisted Queries (APQ)

ะะปะธะตะฝั ะพัะฟัะฐะฒะปัะตั **ัะตั** ะทะฐะฟัะพัะฐ ะฒะผะตััะพ ะฟะพะปะฝะพะณะพ ัะตะบััะฐ.

```bash
# ะะตัะฒัะน ะทะฐะฟัะพั
POST /graphql
{ "extensions": { "persistedQuery": { "sha256Hash": "abc123..." } } }

# ะกะตัะฒะตั ะพัะฒะตัะฐะตั: ะฝะตะธะทะฒะตััะฝัะน ัะตั
# ะะปะธะตะฝั ะพัะฟัะฐะฒะปัะตั ะฟะพะปะฝัะน ะทะฐะฟัะพั
POST /graphql
{ "query": "query {...}", "extensions": {...} }

# ะะพัะปะตะดัััะธะต ะทะฐะฟัะพัั - ัะพะปัะบะพ ัะตั
POST /graphql
{ "extensions": { "persistedQuery": { "sha256Hash": "abc123..." } } }
```

---

### 2. Response Caching

```go
srv.Use(extension.AutomaticPersistedQuery{
    Cache: lru.New(100), // LRU ะบะตั
})
```

---

### 3. DataLoader (ัะผ. ะฒััะต)

ะะตัะธััะตั ะดะฐะฝะฝัะต ะฝะฐ ะฒัะตะผั ะพะดะฝะพะณะพ ะทะฐะฟัะพัะฐ.

---

## ๐ป ะะตะฐะปะธะทะฐัะธั ะฝะฐ Go ั gqlgen

### ะฃััะฐะฝะพะฒะบะฐ

```bash
go get github.com/99designs/gqlgen
go run github.com/99designs/gqlgen init
```

### ะกัััะบัััะฐ ะฟัะพะตะบัะฐ

```
project/
โโโ graph/
โ   โโโ schema.graphqls     # GraphQL ััะตะผะฐ
โ   โโโ generated.go        # ะะฒัะพะณะตะฝะตัะฐัะธั
โ   โโโ model/
โ   โ   โโโ models_gen.go
โ   โโโ resolver.go         # ะะฐัะธ ัะตะทะพะปะฒะตัั
โโโ server.go
โโโ gqlgen.yml              # ะะพะฝัะธะณััะฐัะธั
```

### schema.graphqls

```graphql
type User {
  id: ID!
  username: String!
  email: String!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
}

type Query {
  user(id: ID!): User
  users: [User!]!
}

type Mutation {
  createUser(username: String!, email: String!): User!
}

type Subscription {
  userCreated: User!
}
```

### resolver.go

```go
package graph

import (
    "context"
    "myapp/graph/model"
)

type Resolver struct {
    users map[string]*model.User
}

func (r *Resolver) Query() QueryResolver {
    return &queryResolver{r}
}

func (r *Resolver) Mutation() MutationResolver {
    return &mutationResolver{r}
}

type queryResolver struct{ *Resolver }

func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
    user, ok := r.users[id]
    if !ok {
        return nil, fmt.Errorf("user not found")
    }
    return user, nil
}

func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
    users := make([]*model.User, 0, len(r.users))
    for _, u := range r.users {
        users = append(users, u)
    }
    return users, nil
}

type mutationResolver struct{ *Resolver }

func (r *mutationResolver) CreateUser(ctx context.Context, username, email string) (*model.User, error) {
    user := &model.User{
        ID:       generateID(),
        Username: username,
        Email:    email,
    }
    r.users[user.ID] = user
    return user, nil
}
```

### server.go

```go
package main

import (
    "log"
    "net/http"
    
    "github.com/99designs/gqlgen/graphql/handler"
    "github.com/99designs/gqlgen/graphql/playground"
    "myapp/graph"
    "myapp/graph/generated"
)

func main() {
    srv := handler.NewDefaultServer(
        generated.NewExecutableSchema(
            generated.Config{
                Resolvers: &graph.Resolver{
                    users: make(map[string]*model.User),
                },
            },
        ),
    )
    
    http.Handle("/", playground.Handler("GraphQL", "/query"))
    http.Handle("/query", srv)
    
    log.Println("Server started at http://localhost:8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

---

## โ๏ธ ะะพะณะดะฐ ะะ ััะพะธั ะธัะฟะพะปัะทะพะฒะฐัั GraphQL

| ะกัะตะฝะฐัะธะน | ะะพัะตะผั ะะ GraphQL |
|:---|:---|
| **ะัะพัััะต CRUD** | Overhead ะฝะต ะพะฟัะฐะฒะดะฐะฝ ะดะปั 2-3 ัะฐะฑะปะธั |
| **ะัะฑะปะธัะฝะพะต API ะฑะตะท ะบะพะฝััะพะปั ะบะปะธะตะฝัะพะฒ** | ะกะปะพะถะฝะพ ะฟัะตะดัะบะฐะทะฐัั ะฝะฐะณััะทะบั |
| **ะคะฐะนะปะพะฒัะต ะพะฟะตัะฐัะธะธ** | REST ะฟัะพัะต ะดะปั upload/download |
| **HTTP ะบััะธัะพะฒะฐะฝะธะต ะบัะธัะธัะฝะพ** | ะ GraphQL ัะปะพะถะฝะตะต |
| **ะะพะผะฐะฝะดะฐ ะฝะต ะทะฝะฐะบะพะผะฐ ั GraphQL** | ะัะธะฒะฐั ะพะฑััะตะฝะธั ะฒััะพะบะฐั |

---

## ๐ฏ Best Practices

> [!IMPORTANT]
> **ะะพะปะพััะต ะฟัะฐะฒะธะปะฐ**:
> 1. **ะัะตะณะดะฐ ะธัะฟะพะปัะทัะนัะต DataLoader** ะดะปั ะธะทะฑะตะถะฐะฝะธั N+1
> 2. **ะะณัะฐะฝะธัะธะฒะฐะนัะต ัะปะพะถะฝะพััั ะทะฐะฟัะพัะพะฒ** (depth, cost)
> 3. **ะัะฟะพะปัะทัะนัะต cursor pagination** ะฒะผะตััะพ offset
> 4. **ะะต ะฒะพะทะฒัะฐัะฐะนัะต null ะฑะตะท ะฝะตะพะฑัะพะดะธะผะพััะธ** (ะปัััะต `!` ะฒ ััะตะผะต)
> 5. **ะะพะบัะผะตะฝัะธััะนัะต ััะตะผั** ั ะฟะพะผะพััั `"""ะพะฟะธัะฐะฝะธะต"""`
>
> GraphQL โ ััะพ ะฟัะพ **ัััะตะบัะธะฒะฝะพััั ััะพะฝัะตะฝะดะฐ**. ะัะปะธ ั ะฒะฐั ัะปะพะถะฝัะน UI ั ะผะฝะพะถะตััะฒะพะผ ัะฒัะทะตะน โ ััะพ ะฒะฐั ะฒัะฑะพั. ๐ฑ๐ป๐ก๏ธ
