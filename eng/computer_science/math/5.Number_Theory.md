# ðŸ”¢ Number Theory

## ðŸ“‘ Table of Contents
1. [Prime Numbers](#1-prime-numbers)
2. [GCD and LCM](#2-gcd-and-lcm)
3. [Modular Arithmetic](#3-modular-arithmetic)

---

## 1. ðŸ¥‡ Prime Numbers

A **Prime Number** is a natural number greater than 1 that has no positive divisors other than 1 and itself: 2, 3, 5, 7, 11, 13, and so on.

> [!NOTE]
> By definition, 1 is **not** a prime number. 2 is the only even prime number.

### Why do they matter?

- **Cryptography**: RSA encryption relies on the extreme difficulty of factoring the product of two very large prime numbers.
- **Hashing**: Hash table sizes are often chosen as prime numbers to ensure a more uniform distribution of keys and fewer collisions.

### Primality Testing (Naive Method)

```go
func isPrime(n int) bool {
    if n <= 1 {
        return false
    }
    if n == 2 {
        return true
    }
    if n%2 == 0 {
        return false // Any other even number is not prime
    }
    
    // Check divisors from 3 up to âˆšn
    for i := 3; i*i <= n; i += 2 {
        if n%i == 0 {
            return false
        }
    }
    
    return true
}
```

**Complexity**: $O(\sqrt{n})$

---

### Sieve of Eratosthenes â€” Finding All Primes up to N

A highly efficient algorithm for generating **all** prime numbers up to a given limit $N$.

```go
func sieveOfEratosthenes(n int) []int {
    if n < 2 {
        return []int{}
    }
    
    // Create a boolean array, initialized to true
    isPrime := make([]bool, n+1)
    for i := 2; i <= n; i++ {
        isPrime[i] = true
    }
    
    // Mark composite numbers
    for i := 2; i*i <= n; i++ {
        if isPrime[i] {
            // Mark all multiples of i starting from i*i
            for j := i * i; j <= n; j += i {
                isPrime[j] = false
            }
        }
    }
    
    // Collect the results
    primes := []int{}
    for i := 2; i <= n; i++ {
        if isPrime[i] {
            primes = append(primes, i)
        }
    }
    
    return primes
}

func main() {
    primes := sieveOfEratosthenes(30)
    fmt.Println(primes) // Output: [2 3 5 7 11 13 17 19 23 29]
}
```

**Complexity**: $O(n \log \log n)$ â€” incredibly fast!

---

## 2. ðŸ“ GCD and LCM

### GCD (Greatest Common Divisor)

The **Greatest Common Divisor** of two or more integers is the largest positive integer that divides each of the integers without a remainder.

**Example**: $GCD(12, 18) = 6$ (both are divisible by 6).

### Euclidean Algorithm

A classic and highly efficient algorithm for calculating the GCD.

**Logic**: $GCD(a, b) = GCD(b, a \bmod b)$

```go
func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}

func main() {
    fmt.Println(gcd(48, 18))  // Output: 6
    fmt.Println(gcd(100, 35)) // Output: 5
}
```

**Complexity**: $O(\log \min(a, b))$ â€” near-instantaneous even for large numbers.

**Recursive implementation**:
```go
func gcdRecursive(a, b int) int {
    if b == 0 {
        return a
    }
    return gcdRecursive(b, a%b)
}
```

---

### LCM (Least Common Multiple)

The **Least Common Multiple** of two integers $a$ and $b$ is the smallest positive integer that is divisible by both $a$ and $b$.

**Formula**:
$$\text{LCM}(a, b) = \frac{|a \times b|}{\text{GCD}(a, b)}$$

```go
func lcm(a, b int) int {
    if a == 0 || b == 0 {
        return 0
    }
    return (a * b) / gcd(a, b)
}

func main() {
    fmt.Println(lcm(12, 18)) // Output: 36
    fmt.Println(lcm(4, 6))   // Output: 12
}
```

**Practical use cases**:
- Event synchronization (e.g., if event A occurs every 5 days and event B every 7, when will they co-occur?).
- Music theory and rhythm synchronization across different time signatures.

---

## 3. ðŸ•’ Modular Arithmetic (%)

Modular arithmetic is "clock arithmetic" â€” working with remainders.

**Example**: $17 \bmod 5 = 2$ (because $17 = 5 \times 3 + 2$).

### Why does it matter?

- **Hash Tables**: `index = hash(key) % tableSize` ensures keys fall within array bounds.
- **Cryptography**: Virtually all modern cryptographic operations are performed modulo a very large prime.
- **Cyclic Systems**: Calculating days of the week, hours in a day, or circular buffers.

### Core Properties

Modular arithmetic preserves basic operations:

$$
\begin{align*}
(a + b) \bmod m &= ((a \bmod m) + (b \bmod m)) \bmod m \\
(a \times b) \bmod m &= ((a \bmod m) \times (b \bmod m)) \bmod m
\end{align*}
$$

```go
func modAdd(a, b, m int) int {
    return ((a % m) + (b % m)) % m
}

func modMul(a, b, m int) int {
    return ((a % m) * (b % m)) % m
}
```

---

### Modular Exponentiation

Calculating $a^b \bmod m$ for potentially massive values of $b$ (e.g., $2^{1000} \bmod 7$).

A naive approach ($a \times a \times ...) $ is computationally infeasible. **Modular Exponentiation** solves this in $O(\log b)$ time:

```go
func modPow(base, exp, mod int) int {
    result := 1
    base = base % mod
    
    for exp > 0 {
        // If exp is odd
        if exp%2 == 1 {
            result = (result * base) % mod
        }
        
        // Bitwise shift: exp = exp / 2
        exp = exp >> 1
        // Squaring the base: base = (base * base) % mod
        base = (base * base) % mod
    }
    
    return result
}

func main() {
    fmt.Println(modPow(2, 10, 1000))   // 1024 % 1000 = 24
    fmt.Println(modPow(3, 100, 7))     // 3^100 % 7 = 4
    fmt.Println(modPow(5, 1000, 13))   // 5^1000 % 13 = 8
}
```

**Common applications**:
- RSA Key generation and encryption.
- Calculating high powers within competitive programming constraints.

---

### Practical Example: Hash Tables

```go
const tableSize = 101 // A prime number is used for optimal distribution

func hash(key string) int {
    sum := 0
    for _, char := range key {
        sum += int(char)
    }
    return sum % tableSize // Modulo determines the bucket index
}

func main() {
    fmt.Println(hash("hello")) // Bucket index
    fmt.Println(hash("world")) // Distinct bucket index
}
```

---

## ðŸ’¡ Summary

| Concept | Key Algorithm | Complexity | Primary Use Case |
|:---|:---|:---|:---|
| **Primes** | Sieve of Eratosthenes | $O(n \log \log n)$ | Cryptographic Keys (RSA) |
| **GCD** | Euclidean Algorithm | $O(\log \min(a,b))$ | Reducing fractions |
| **LCM** | Relationship with GCD | $O(\log \min(a,b))$ | Task Synchronization |
| **Modular Arith.** | Modular Exponentiation | $O(\log n)$ | Hashing, Cryptography |

> [!TIP]
> Number Theory isn't just theoryâ€”it powers the security and efficiency of almost every digital system we use today!
