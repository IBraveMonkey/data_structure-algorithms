# üî¢ Bits, Bytes, and Numeral Systems

## üìë Table of Contents
1. [Numeral Systems](#numeral-systems)
2. [Bits and Bytes](#bits-and-bytes)
3. [Data Encoding](#data-encoding)
4. [Bitwise Operations](#bitwise-operations)

---

Computers work with data represented as **bits** (binary digits) and **bytes**. This section explains how data is encoded, stored, and processed using various numeral systems.

```mermaid
graph TD
    Data[Data] --> Binary[Binary<br/>Representation]
    Binary --> Bits[Bits 0/1]
    Bits --> Bytes[Bytes 8-bit]
    Bytes --> KB[Kilobytes]
    KB --> MB[Megabytes]
    MB --> GB[Gigabytes]
    
    Binary --> Encoding[Encoding]
    Encoding --> Text[Text ASCII/Unicode]
    Encoding --> Numbers[Numbers Int/Float]
    Encoding --> Media[Media RGB/Audio]
```

---

## 1. üìÇ Numeral Systems

A numeral system is a way of representing numbers using symbols (digits) and their positions.

### Common Systems üèõÔ∏è

| System | Base | Digits | Example | Decimal Equivalent |
|:---|:---:|:---|:---:|:---:|
| **Binary** | 2 | 0, 1 | 1010 | 10 |
| **Octal** | 8 | 0-7 | 12 | 10 |
| **Decimal** | 10 | 0-9 | 10 | 10 |
| **Hexadecimal** | 16 | 0-9, A-F | A | 10 |

### Conversion Between Systems üîÑ

#### From Binary to Decimal

```
1010‚ÇÇ = 1√ó2¬≥ + 0√ó2¬≤ + 1√ó2¬π + 0√ó2‚Å∞
     = 8 + 0 + 2 + 0
     = 10‚ÇÅ‚ÇÄ
```

```mermaid
graph LR
    B[1010‚ÇÇ] --> B3[1√ó2¬≥=8]
    B --> B2[0√ó2¬≤=0]
    B --> B1[1√ó2¬π=2]
    B --> B0[0√ó2‚Å∞=0]
    
    B3 --> Sum[8+0+2+0]
    B2 --> Sum
    B1 --> Sum
    B0 --> Sum
    Sum --> Result[10‚ÇÅ‚ÇÄ]
```

#### From Decimal to Binary

Divide by 2 and record the remainders in reverse order:

```
10 √∑ 2 = 5 remainder 0
 5 √∑ 2 = 2 remainder 1
 2 √∑ 2 = 1 remainder 0
 1 √∑ 2 = 0 remainder 1

Read bottom-up: 1010‚ÇÇ
```

#### Binary ‚Üî Hexadecimal

Group by 4 bits (nibbles):

```
1010 1110‚ÇÇ = AE‚ÇÅ‚ÇÜ
‚îî‚îÄ‚î¨‚îÄ‚îò ‚îî‚îÄ‚î¨‚îÄ‚îò
  A     E
```

> [!TIP]
> **Example**: The number 42 in different systems:
> - Decimal: `42`
> - Binary: `101010`
> - Hexadecimal: `2A`

---

## 2. üíæ Bits and Bytes

Bits and bytes are the fundamental units of information in a computer.

### Bit

- **The smallest unit of information**: either 0 or 1.
- Corresponds to an electrical signal (e.g., 0V = 0, 5V = 1).

### Byte

- **8 bits**. Example: `10110011`.
- Can represent **256 unique values** (2‚Å∏, from `00000000` to `11111111`).

```mermaid
graph LR
    Bit[1 bit] --> Byte[1 byte = 8 bits]
    Byte --> Values[256 values<br/>0-255]
    
    subgraph Example["Example Byte"]
        B7[1] --- B6[0] --- B5[1] --- B4[1] --- B3[0] --- B2[0] --- B1[1] --- B0[1]
    end
```

### Larger Units üì¶

| Unit | Size | In Bytes | Example |
|:---|:---|:---:|:---|
| **Kilobyte (KB)** | 1024 bytes | 2¬π‚Å∞ | A plain text document |
| **Megabyte (MB)** | 1024 KB | 2¬≤‚Å∞ | An MP3 song (~3-5 MB) |
| **Gigabyte (GB)** | 1024 MB | 2¬≥‚Å∞ | An HD video (~1-4 GB) |
| **Terabyte (TB)** | 1024 GB | 2‚Å¥‚Å∞ | A hard drive |
| **Petabyte (PB)** | 1024 TB | 2‚Åµ‚Å∞ | A data center |

> [!NOTE]
> The character `A` in ASCII takes up **1 byte** (`01000001` = 65 in decimal).

---

## 3. üîê Data Encoding

Data in a computer is encoded in binary form to represent text, numbers, and other types of information.

### Text Encoding ‚úçÔ∏è

#### ASCII
- **7 or 8 bits** per character.
- Supports 128 (7-bit) or 256 (8-bit) characters.

**Examples**:
| Character | Decimal | Binary | Hexadecimal |
|:---:|:---:|:---:|:---:|
| A | 65 | 01000001 | 41 |
| a | 97 | 01100001 | 61 |
| 0 | 48 | 00110000 | 30 |
| Space | 32 | 00100000 | 20 |

#### Unicode
- **An expanded standard** to support all the world's languages.
- UTF-8, UTF-16, UTF-32 (different encoding schemes).
- Example: `U+0410` for the Cyrillic letter `–ê`.

```mermaid
graph LR
    ASCII[ASCII<br/>128-256 chars] --> Unicode[Unicode<br/>149,186 chars]
    Unicode --> UTF8[UTF-8<br/>1-4 bytes]
    Unicode --> UTF16[UTF-16<br/>2-4 bytes]
    Unicode --> UTF32[UTF-32<br/>4 bytes]
```

### Number Encoding üî¢

#### Integers

**Unsigned**:
```
1010‚ÇÇ = 10‚ÇÅ‚ÇÄ
```

**Signed (Two's Complement)**:
- The first bit is the sign bit (0 = positive, 1 = negative).
- To get a negative number: invert the bits and add 1.

```
Example (4 bits):
 2‚ÇÅ‚ÇÄ = 0010‚ÇÇ
-2‚ÇÅ‚ÇÄ = 1110‚ÇÇ (invert: 1101, add 1: 1110)
```

#### Floating-Point Numbers (IEEE 754)

```mermaid
graph LR
    subgraph Float_32["32-bit float"]
        Sign[Sign<br/>1 bit] --- Exp[Exponent<br/>8 bits] --- Mant[Mantissa<br/>23 bits]
    end
    
    Formula[value = -1^sign √ó 1.mantissa √ó 2^exp-127]
```

> [!IMPORTANT]
> Floating-point numbers have limited precision! `0.1 + 0.2` might not be exactly `0.3` in binary representation.

### Other Data Types üé®

**Images**:
- Pixels are encoded as RGB combinations.
- Example: 24 bits per pixel (8 bits red + 8 green + 8 blue).

**Sound**:
- Amplitude is digitized.
- Example: 16 bits per sample, 44,100 Hz (CD quality).

> [!TIP]
> The word `Hi` in ASCII:
> - `H` = `01001000` (72‚ÇÅ‚ÇÄ)
> - `i` = `01101001` (105‚ÇÅ‚ÇÄ)

---

## 4. ‚ö° Bitwise Operations

Bitwise operations manipulate individual bits of numbers and are used in programming and hardware.

### Common Operations ‚ö°

| Operation | Description | Example | Result |
|:---|:---|:---:|:---:|
| **AND** (`&`) | 1 if both bits are 1 | `1010 & 1100` | `1000` |
| **OR** (`|`) | 1 if at least one bit is 1 | `1010 | 1100` | `1110` |
| **XOR** (`^`) | 1 if bits are different | `1010 ^ 1100` | `0110` |
| **NOT** (`~`) | Bit inversion | `~1010` | `0101` |
| **Left Shift** (`<<`) | Bits move to the left | `1010 << 1` | `0100` |
| **Right Shift** (`>>`) | Bits move to the right | `1010 >> 1` | `0101` |

### Visualization of Operations

```mermaid
graph TD
    subgraph AND_Operation["AND: 1010  & 1100"]
        A1[1] --> R1[1]
        A2[0] --> R2[0]
        A3[1] --> R3[0]
        A4[0] --> R4[0]
    end
    
    Result[Result: 1000]
    
    style R1 fill:#90EE90
    style R2 fill:#FFB6B1
    style R3 fill:#FFB6C1
    style R4 fill:#FFB6C1
```

### Applications üöÄ

#### Masks
Isolating specific bits:
```
value & 00001111  // Keeps the lower 4 bits
```

#### Optimization
Shifting instead of multiplying/dividing by 2:
```
x << 1   // Multiply by 2
x >> 1   // Divide by 2
```

#### Encryption
Using XOR for simple encryption:
```
encrypted = data ^ key
decrypted = encrypted ^ key  // XOR is reversible!
```

#### Parity Check
```
n & 1  // If result is 0, the number is even
```

> [!TIP]
> **Practical Example**: To check if the 5th bit of a number `n` is set:
> ```
> if (n & (1 << 5)) {
>     // The 5th bit is set
> }
> ```

---

## üéØ Key Takeaways

```mermaid
mindmap
  root((Bits and<br/>Bytes))
    Numeral Systems
      Binary 0-1
      Octal 0-7
      Decimal 0-9
      Hexadecimal 0-F
    Units
      Bit 0/1
      Byte 8-bit
      KB MB GB TB
    Encoding
      Text ASCII Unicode
      Numbers Int Float
      Media RGB Audio
    Bitwise Operations
      AND OR XOR NOT
      Shifts
      Masks
```

- **Numeral Systems** (binary, hexadecimal) are the basis of data representation in a computer.
- **Bits** (0/1) and **bytes** (8 bits) are the smallest units of information.
- Data is encoded in binary form: text (ASCII, Unicode), numbers (integers, floating-point), images, and sound.
- **Bitwise operations** (AND, OR, XOR, shifts) are used for low-level data manipulation.
- Understanding bits and bytes is essential for working with memory, processors, and optimizing software.
