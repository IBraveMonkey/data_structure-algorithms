# üß† Digital Logic and Boolean Algebra

## üìë Table of Contents
1. [Boolean Algebra](#boolean-algebra)
2. [Combinational Logic](#combinational-logic)
3. [Sequential Logic](#sequential-logic)
4. [Finite State Machines](#finite-state-machines)

---

Digital logic is the foundation of computer operation, allowing binary signals (**0** and **1**) to be processed using logical operations. Boolean algebra provides the mathematical framework for the design and analysis of digital circuits.

```mermaid
graph TD
    Boolean[Boolean Algebra] --> Combinational[Combinational Logic]
    Boolean --> Sequential[Sequential Logic]
    
    Combinational --> Adders[Adders]
    Combinational --> MUX[Multiplexers]
    
    Sequential --> Flip[Flip-Flops]
    Sequential --> Registers[Registers]
    Sequential --> FSM[Finite State Machines]
    
    Adders --> CPU[CPU/ALU]
    Registers --> CPU
    FSM --> CPU
```

---

## 1. üìê Boolean Algebra

Boolean algebra is a branch of mathematics that deals with logical values (**TRUE/1** and **FALSE/0**) and operations performed on them.

### Basic Operations ‚ö°

```mermaid
graph LR
    subgraph AND_Gate["AND"]
        A1[A] --> AND{AND}
        B1[B] --> AND
        AND --> Out1[1 only if<br/>A=1 AND B=1]
    end
    
    subgraph OR_Gate["OR"]
        A2[A] --> OR{OR}
        B2[B] --> OR
        OR --> Out2[1 if<br/>A=1 OR B=1]
    end
    
    subgraph NOT_Gate["NOT"]
        A3[A] --> NOT{NOT}
        NOT --> Out3[Inversion<br/>0‚Üí1, 1‚Üí0]
    end
```

| Operation | Notation | Description | Result is 1 if... |
|:---|:---:|:---|:---|
| **AND** | A ‚àß B | Logical AND | Both A and B are 1 |
| **OR** | A ‚à® B | Logical OR | At least one of A or B is 1 |
| **NOT** | ¬¨A | Inversion | A = 0 |
| **NAND** | ¬¨(A ‚àß B) | Negated AND | Not all inputs are 1 |
| **NOR** | ¬¨(A ‚à® B) | Negated OR | All inputs are 0 |
| **XOR** | A ‚äï B | Exclusive OR | Exactly one input is 1 |

### Boolean Laws üìö

| Law | Example |
|:---|:---|
| **Commutative** | A ‚àß B = B ‚àß A, A ‚à® B = B ‚à® A |
| **Associative** | (A ‚àß B) ‚àß C = A ‚àß (B ‚àß C) |
| **Distributive** | A ‚àß (B ‚à® C) = (A ‚àß B) ‚à® (A ‚àß C) |
| **De Morgan's** | ¬¨(A ‚àß B) = ¬¨A ‚à® ¬¨B, ¬¨(A ‚à® B) = ¬¨A ‚àß ¬¨B |
| **Idempotent** | A ‚àß A = A, A ‚à® A = A |

> [!TIP]
> **Application**: Simplifying logical expressions to optimize circuits and design digital devices (e.g., processors).

> [!NOTE]
> **Simplification Example**: Let's simplify A ‚àß (A ‚à® B).
> 
> Using the distributive law: A ‚àß (A ‚à® B) = (A ‚àß A) ‚à® (A ‚àß B) = A ‚à® (A ‚àß B)
> 
> Then: A ‚à® (A ‚àß B) = A (Absorption Law)

---

## 2. üß© Combinational Logic

Combinational logic refers to circuits where the output depends **only on the current inputs**, without regard to previous states.

### Core Elements

#### Adder

Adds binary numbers.

- **Half Adder**: Adds two bits, producing a sum and a carry.
- **Full Adder**: Adds two bits while accounting for an input carry.

```mermaid
graph TD
    subgraph Half_Adder["Half Adder"]
        A[Input A] --> XOR1{XOR}
        B[Input B] --> XOR1
        A --> AND1{AND}
        B --> AND1
        XOR1 --> Sum[Sum = A ‚äï B]
        AND1 --> Carry[Carry = A ‚àß B]
    end
    
    style Sum fill:#90EE90
    style Carry fill:#FFB6C1
```

**Half Adder Truth Table**:

| A | B | Sum (A ‚äï B) | Carry (A ‚àß B) |
|:---:|:---:|:---:|:---:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

#### Multiplexer (MUX)

Selects one of several input signals based on a control signal.

```mermaid
graph LR
    I0[Input 0] --> MUX{MUX}
    I1[Input 1] --> MUX
    I2[Input 2] --> MUX
    I3[Input 3] --> MUX
    Sel[Selector<br/>2 bits] --> MUX
    MUX --> Out[Output]
```

#### Demultiplexer (DEMUX)

Directs a single input signal to one of several outputs.

#### Decoder / Encoder

- **Decoder**: Converts binary code into a signal on one of its outputs (e.g., `00` ‚Üí output 0, `01` ‚Üí output 1).
- **Encoder**: The inverse of a decoder; converts a signal into binary code.

> [!IMPORTANT]
> In a processor, adders are used in the **ALU** (Arithmetic Logic Unit) to perform addition, subtraction, and other arithmetic operations.

---

## 3. ‚è≥ Sequential Logic

Sequential logic refers to circuits where the output depends on **current inputs AND previous states** (memory).

### Core Elements

#### Flip-Flops

Store **1 bit** of information.

```mermaid
graph TD
    subgraph Flip_Flops["Types of Flip-Flops"]
        SR[SR Flip-Flop<br/>Set/Reset]
        D[D Flip-Flop<br/>Data]
        JK[JK Flip-Flop<br/>Universal]
    end
    
    CLK[Clock Signal] -.-> SR
    CLK -.-> D
    CLK -.-> JK
    
    SR --> State1[State: 0 or 1]
    D --> State2[State: 0 or 1]
    JK --> State3[State: 0 or 1]
```

**Common Types**:

- **SR Flip-Flop**: Sets (S) or resets (R) the stored value.
- **D Flip-Flop**: Stores the input value on a synchronization signal (clock signal).
- **JK Flip-Flop**: A versatile flip-flop that can change state based on complex conditions.

#### Register

A collection of flip-flops used to store multiple bits (e.g., a 32-bit register).

```mermaid
graph LR
    subgraph Register_32bit["32-bit Register"]
        D0[D0] --> T0[Flip-Flop 0]
        D1[D1] --> T1[Flip-Flop 1]
        D2[...] --> T2[...]
        D31[D31] --> T31[Flip-Flop 31]
    end
    
    CLK[Clock<br/>Signal] -.-> T0
    CLK -.-> T1
    CLK -.-> T2
    CLK -.-> T31
```

#### Counter

Sequentially increments a value (e.g., from `000` to `111` in binary).

### Clock Signal ‚è±Ô∏è

```mermaid
graph LR
    subgraph Clock_Signal["Clock Signal"]
        direction LR
        High1[‚ñÅ‚ñî] --> High2[‚ñÅ‚ñî] --> High3[‚ñÅ‚ñî] --> High4[‚ñÅ‚ñî]
    end
    
    Freq[Frequency: 3 GHz = 3 billion pulses/sec]
```

- Synchronizes circuit operation.
- The clock frequency determines how often states are updated.

> [!NOTE]
> Processor registers store intermediate calculation results, such as variable values or memory addresses.

---

## 4. ü§ñ Finite State Machines

A **Finite State Machine (FSM)** is a model describing the behavior of a system with a limited number of states.

### Components üß±

- **States**: E.g., "on", "off".
- **Transitions**: Conditions under which the system changes state (e.g., "button pressed").
- **Inputs**: Signals that trigger transitions.
- **Outputs**: Results that depend on the state or inputs.

### Visualization: Traffic Light

```mermaid
stateDiagram-v2
    [*] --> Green
    Green --> Yellow : Timer (30 sec)
    Yellow --> Red : Timer (3 sec)
    Red --> Green : Timer (30 sec)
    
    note right of Green
        Cars proceed
    end note
    note right of Yellow
        Prepare to stop
    end note
    note right of Red
        Stop!
    end note
```

### Types üé®

| Type | Description | Output Depends On |
|:---|:---|:---|
| **Moore Machine** | Output depends exclusively on the current state | State only |
| **Mealy Machine** | Output depends on both current state and inputs | State + inputs |

### Applications üöÄ

- Process management in CPUs.
- Communication protocols (e.g., USB, TCP/IP).
- Game logic.
- Device control.

> [!TIP]
> **Example**: A processor uses FSMs to manage the **instruction pipeline** (Fetch ‚Üí Decode ‚Üí Execute ‚Üí Write Back).

---

## üéØ Key Takeaways

```mermaid
mindmap
  root((Digital<br/>Logic))
    Boolean Algebra
      AND OR NOT
      Laws
      Circuit optimization
    Combinational
      Stateless
      Adders
      MUX DEMUX
      ALU
    Sequential
      Memory-based
      Flip-Flops
      Registers
      Counters
    FSM
      States
      Transitions
      Control
      Protocols
```

- **Boolean Algebra** is the mathematical foundation for logical operations.
- **Combinational Logic** creates circuits that depend solely on inputs (adders, multiplexers).
- **Sequential Logic** adds memory via flip-flops and registers, synchronized by a clock signal.
- **Finite State Machines** model system behavior through states (processors, protocols, devices).
- These concepts are the bedrock for designing processors and other digital systems.
