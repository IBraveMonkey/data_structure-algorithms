package counting_sort

/*
 Работает за линейное время O(n), но применим только для сортировки целых чисел(или данных, которые можно свеcти к целым числам) в определенном диапазоне.Он эффективен, когда диапазон значений(разница между минимальным и максимальным элементом) не слишком велик

 Как работает
 1) Определение диапазона - Находим минимальное и максимальное значение в массиве

 2) Создание массива подсчета: создаем вспомогательным массив count, где индекс соотвествует значению элемента, а значение - кол-ву таких элементов в исходном массиве

 Работает по timeComplexity за O(n + k), где n - кол-во элементов, а k - диапазон значений,

 по spaceComplexity - O(k), так как требует доп массив для подсчета

 Не подходит для сортировки данных с большим диапазоном значений( например, числа от 1 до 10^6)

*/

// arr = []int{4,2,2,8,3,3,1}
func CountingSort(arr []int) []int {
	if len(arr) == 0 {
		return arr
	}

	// 1, 8
	min, max := arr[0], arr[0]
	for _, v := range arr {
		if v < min {
			min = v
		}

		if v > max {
			max = v
		}
	}

	count := make([]int, max-(max+1))
	for _, v := range arr {
		count[v-min]++
	}

	sortedIndex := 0
	for i, c := range count {
		for c > 0 {
			arr[sortedIndex] = i + min
			sortedIndex++
			c--
		}
	}

	return arr
}
