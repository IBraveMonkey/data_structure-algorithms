**Apache Kafka** и **RabbitMQ** — это системы обмена сообщениями, используемые для асинхронной коммуникации в распределенных системах. Однако они решают разные задачи: Kafka — платформа для потоковой обработки больших объемов данных, а RabbitMQ — универсальный брокер сообщений с гибкой маршрутизацией. Этот конспект сравнивает их архитектуру, компоненты, протоколы, сценарии использования и предоставляет простые примеры на Go.

---

## Основные отличия

|                        |                                                                  |                                                             |
| ---------------------- | ---------------------------------------------------------------- | ----------------------------------------------------------- |
| **Характеристика**     | **Kafka**                                                        | **RabbitMQ**                                                |
| **Тип**                | Платформа потоковой обработки событий (Event Streaming Platform) | Универсальный брокер сообщений (Message Broker)             |
| **Архитектура**        | Лог-ориентированная, сообщения хранятся в виде логов             | Очередь-ориентированная, сообщения удаляются после доставки |
| **Протоколы**          | Собственный бинарный протокол на TCP                             | AMQP (0.9.1, 1.0), MQTT, STOMP, HTTP (через плагины)        |
| **Производительность** | Высокая пропускная способность (миллионы сообщений/сек)          | Высокая, но ниже Kafka (тысячи–десятки тысяч сообщений/сек) |
| **Хранение данных**    | Долгосрочное, сообщения хранятся на диске (настраиваемый TTL)    | Краткосрочное, сообщения удаляются после подтверждения      |
| **Маршрутизация**      | Простая, на основе топиков и партиций                            | Гибкая, с exchanges (direct, topic, fanout, headers)        |
| **Модель доставки**    | Pull (потребители запрашивают сообщения)                         | Push (брокер отправляет сообщения потребителям)             |
| **Сценарии**           | Потоковая аналитика, большие данные, логи, IoT                   | Микросервисы, фоновые задачи, сложная маршрутизация         |
| **Язык**               | Java/Scala                                                       | Erlang                                                      |

---

## Apache Kafka

### Что это

Kafka — распределенная платформа для обработки потоков событий, оптимизированная для высокопроизводительной обработки больших объемов данных в реальном времени. Она хранит сообщения в виде логов, поддерживает воспроизведение (replay) и масштабируется горизонтально.

### Когда использовать

- **Потоковая обработка**: Аналитика в реальном времени (дашборды, обнаружение мошенничества).
- **Логи и мониторинг**: Сбор логов, метрик, IoT-данных.
- **Событийно-ориентированные системы**: Хранение истории событий (event sourcing).
- **Большие данные**: Интеграция с Hadoop, Spark, Flink.

### Внутренние компоненты

1. **Broker**: Сервер Kafka, хранящий данные и обслуживающий клиентов. Кластер состоит из нескольких брокеров.
2. **Topic**: Категория сообщений, разделенная на **партиции** для параллелизма.
3. **Partition**: Упорядоченный лог сообщений, хранящийся на диске. Каждая партиция имеет лидера и реплики.
4. **Producer**: Отправляет сообщения в топик.
5. **Consumer**: Читает сообщения из топика. Потребители объединяются в **consumer groups** для распределения нагрузки.
6. **ZooKeeper/KRaft**: Управляет метаданными кластера (ZooKeeper устаревает, заменяется KRaft).
7. **Kafka Streams**: Библиотека для обработки потоков данных.
8. **Kafka Connect**: Интеграция с внешними системами (базами данных, хранилищами).

### Протокол

- Собственный бинарный протокол на TCP, оптимизированный для высокой пропускной способности.
- Поддерживает семантики доставки: **at-most-once**, **at-least-once**, **exactly-once**.

### Как работает

1. Производитель отправляет сообщение в топик, указывая ключ (определяет партицию).
2. Брокер сохраняет сообщение в партиции топика на диске.
3. Потребитель запрашивает сообщения, отслеживая **offset** (позицию в логе).
4. Сообщения хранятся до истечения TTL (настраивается).

### Пример на Go

**Установка**: Используем библиотеку confluent-kafka-go.

```bash
go get github.com/confluentinc/confluent-kafka-go/kafka
```

**Producer**:

```go
package main

import (
	"fmt"
	"github.com/confluentinc/confluent-kafka-go/kafka"
)

func main() {
	// Настройка продюсера
	p, err := kafka.NewProducer(&kafka.ConfigMap{
		"bootstrap.servers": "localhost:9092",
	})
	if err != nil {
		fmt.Printf("Ошибка создания продюсера: %v\n", err)
		return
	}
	defer p.Close()

	// Топик
	topic := "my-topic"

	// Отправка сообщения
	err = p.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{Topic: &topic, Partition: kafka.PartitionAny},
		Value:          []byte("Hello, Kafka!"),
	}, nil)
	if err != nil {
		fmt.Printf("Ошибка отправки: %v\n", err)
	}

	// Ожидание доставки
	p.Flush(15 * 1000)
	fmt.Println("Сообщение отправлено")
}
```

**Consumer**:

```go
package main

import (
	"fmt"
	"github.com/confluentinc/confluent-kafka-go/kafka"
)

func main() {
	// Настройка консюмера
	c, err := kafka.NewConsumer(&kafka.ConfigMap{
		"bootstrap.servers": "localhost:9092",
		"group.id":          "my-group",
		"auto.offset.reset": "earliest",
	})
	if err != nil {
		fmt.Printf("Ошибка создания консюмера: %v\n", err)
		return
	}
	defer c.Close()

	// Подписка на топик
	topic := "my-topic"
	c.SubscribeTopics([]string{topic}, nil)

	// Чтение сообщений
	for {
		msg, err := c.ReadMessage(-1)
		if err == nil {
			fmt.Printf("Получено: %s\n", string(msg.Value))
		} else {
			fmt.Printf("Ошибка: %v\n", err)
			break
		}
	}
}
```

**Запуск**:

1. Установите Kafka: docker run -p 9092:9092 confluentinc/cp-kafka.
2. Создайте топик: kafka-topics --create --topic my-topic --bootstrap-server localhost:9092.
3. Запустите продюсера, затем консюмера.

---

## RabbitMQ

### Что это

RabbitMQ — универсальный брокер сообщений, обеспечивающий гибкую маршрутизацию и надежную доставку сообщений. Подходит для сценариев, требующих сложной маршрутизации и поддержки различных протоколов.

### Когда использовать

- **Микросервисы**: Связь между сервисами (уведомления, обновления статуса).
- **Фоновые задачи**: Обработка длительных операций (отправка email, обработка заказов).
- **Сложная маршрутизация**: Например, отправка сообщений разным потребителям по правилам.
- **IoT**: Обработка данных с устройств с поддержкой MQTT.

### Внутренние компоненты

1. **Exchange**: Принимает сообщения от продюсеров и маршрутизирует их в очереди по правилам (bindings).
   - Типы: **Direct** (по ключу), **Topic** (по шаблону), **Fanout** (всем очередям), **Headers** (по заголовкам).

2. **Queue**: Хранит сообщения до их обработки потребителем.
3. **Binding**: Правило, связывающее exchange и очередь.
4. **Producer**: Отправляет сообщения в exchange.
5. **Consumer**: Получает сообщения из очереди.
6. **Broker**: Сервер RabbitMQ, управляющий exchanges, очередями и сообщениями.
7. **Quorum Queues**: Реплицируемые очереди для высокой доступности (аналог Kafka partitions).
8. **Streams** (с версии 3.9): Поддержка лог-ориентированного хранения, конкурирующего с Kafka.

### Протоколы

- **AMQP 0.9.1** (основной), AMQP 1.0 (через плагин).
- **MQTT**: Для IoT-устройств.
- **STOMP**: Простой текстовый протокол.
- **HTTP**: Через плагины для веб-интеграции.

### Как работает

1. Продюсер отправляет сообщение в exchange.
2. Exchange маршрутизирует сообщение в очередь(и) по правилам binding.
3. Брокер отправляет сообщение из очереди потребителю (push-модель).
4. После подтверждения (acknowledgment) сообщение удаляется из очереди.

### Пример на Go

**Установка**: Используем библиотеку amqp091-go.

```bash
go get github.com/rabbitmq/amqp091-go
```

**Producer**:

```go
package main

import (
	"fmt"
	"github.com/rabbitmq/amqp091-go"
)

func main() {
	// Подключение к RabbitMQ
	conn, err := amqp091.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		fmt.Printf("Ошибка подключения: %v\n", err)
		return
	}
	defer conn.Close()

	// Создание канала
	ch, err := conn.Channel()
	if err != nil {
		fmt.Printf("Ошибка канала: %v\n", err)
		return
	}
	defer ch.Close()

	// Объявление очереди
	q, err := ch.QueueDeclare(
		"my-queue", // Имя очереди
		false,      // Durable
		false,      // Auto-delete
		false,      // Exclusive
		false,      // No-wait
		nil,        // Args
	)
	if err != nil {
		fmt.Printf("Ошибка очереди: %v\n", err)
		return
	}

	// Отправка сообщения
	err = ch.Publish(
		"",     // Exchange
		q.Name, // Routing key
		false,  // Mandatory
		false,  // Immediate
		amqp091.Publishing{
			ContentType: "text/plain",
			Body:        []byte("Hello, RabbitMQ!"),
		})
	if err != nil {
		fmt.Printf("Ошибка отправки: %v\n", err)
		return
	}

	fmt.Println("Сообщение отправлено")
}
```

**Consumer**:

```go
package main

import (
	"fmt"
	"github.com/rabbitmq/amqp091-go"
)

func main() {
	// Подключение к RabbitMQ
	conn, err := amqp091.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		fmt.Printf("Ошибка подключения: %v\n", err)
		return
	}
	defer conn.Close()

	// Создание канала
	ch, err := conn.Channel()
	if err != nil {
		fmt.Printf("Ошибка канала: %v\n", err)
		return
	}
	defer ch.Close()

	// Объявление очереди
	q, err := ch.QueueDeclare(
		"my-queue", // Имя очереди
		false,      // Durable
		false,      // Auto-delete
		false,      // Exclusive
		false,      // No-wait
		nil,        // Args
	)
	if err != nil {
		fmt.Printf("Ошибка очереди: %v\n", err)
		return
	}

	// Получение сообщений
	msgs, err := ch.Consume(
		q.Name, // Queue
		"",     // Consumer tag
		true,   // Auto-ack
		false,  // Exclusive
		false,  // No-local
		false,  // No-wait
		nil,    // Args
	)
	if err != nil {
		fmt.Printf("Ошибка получения: %v\n", err)
		return
	}

	// Чтение сообщений
	for msg := range msgs {
		fmt.Printf("Получено: %s\n", msg.Body)
	}
}
```

**Запуск**:

1. Установите RabbitMQ: docker run -p 5672:5672 rabbitmq.
2. Запустите продюсера, затем консюмера.

---

## Сравнение архитектур

### Kafka

- **Лог-ориентированная модель**:
  - Сообщения хранятся в партициях топиков как упорядоченные логи.
  - Потребители читают по offset’у, могут перечитывать данные.
- **Масштабируемость**:
  - Горизонтальная: добавление брокеров увеличивает пропускную способность.
  - Партиции распределяются по брокерам.
- **Долговечность**:
  - Сообщения хранятся на диске, реплицируются между брокерами.
- **Ограничения**:
  - Меньше гибкости в маршрутизации.
  - Сложнее для небольших проектов из-за зависимости от ZooKeeper/KRaft.

### RabbitMQ

- **Очередь-ориентированная модель**:
  - Сообщения хранятся в очередях, удаляются после доставки (кроме Streams).
  - Гибкая маршрутизация через exchanges.
- **Масштабируемость**:
  - Вертикальная (увеличение ресурсов) и горизонтальная (кластеризация).
  - Quorum Queues обеспечивают репликацию.
- **Долговечность**:
  - Поддерживает персистентные очереди, но данные обычно не хранятся долго.
- **Ограничения**:
  - Меньшая пропускная способность при высоких нагрузках.
  - Требует больше ресурсов для обработки миллионов сообщений.

---

## Протоколы и их влияние

- **Kafka**:
  - Собственный протокол на TCP: высокая производительность, но ограниченная интероперабельность.
  - Подходит для приложений, готовых использовать Kafka-клиенты.
- **RabbitMQ**:
  - AMQP: Стандартизированный, поддерживает сложную маршрутизацию.
  - MQTT/STOMP: Легковесные, для IoT и веб-приложений.
  - Гибкость протоколов делает RabbitMQ универсальным.

---

## Сценарии использования

### Kafka

- **Логирование**: Сбор логов от тысяч серверов.
  ```go
  // Продюсер отправляет логи
  p.Produce(&kafka.Message{
      TopicPartition: kafka.TopicPartition{Topic: &logTopic, Partition: kafka.PartitionAny},
      Value:          []byte("Error: server down"),
  }, nil)
  ```
- **Потоковая аналитика**: Обработка транзакций в реальном времени.
- **IoT**: Сбор данных с миллионов устройств.

### RabbitMQ

- **Микросервисы**: Уведомления между сервисами.
  ```go
  // Продюсер отправляет заказ
  ch.Publish("", "orders", false, false, amqp091.Publishing{
      Body: []byte("Order #123"),
  })
  ```
- **Фоновые задачи**: Обработка изображений, отправка писем.
- **IoT**: Обработка данных с MQTT-устройств.

---

## Плюсы и минусы

### Kafka

**Плюсы**:

- Высокая пропускная способность (миллионы сообщений/сек).
- Долгосрочное хранение данных.
- Встроенная поддержка потоковой обработки (Kafka Streams).
- Масштабируемость для больших данных.

**Минусы**:

- Сложность настройки и управления (ZooKeeper/KRaft).
- Ограниченная маршрутизация.
- Не подходит для мелких проектов.

### RabbitMQ

**Плюсы**:

- Гибкая маршрутизация (exchanges, bindings).
- Поддержка множества протоколов.
- Простота настройки для небольших систем.
- Подходит для микросервисов и IoT.

**Минусы**:

- Меньшая пропускная способность при высоких нагрузках.
- Сообщения обычно не хранятся долго (кроме Streams).
- Требует больше ресурсов для масштабирования.

---

## Как выбрать?

- **Выберите Kafka**, если:
  - Нужна высокая пропускная способность и долгосрочное хранение.
  - Работаете с большими данными, потоками, логами.
  - Пример: Аналитика транзакций в банке.
- **Выберите RabbitMQ**, если:
  - Нужна гибкая маршрутизация и поддержка протоколов.
  - Работаете с микросервисами, фоновыми задачами, IoT.
  - Пример: Уведомления в интернет-магазине.

---

## Пример интеграции (Kafka + RabbitMQ)

**Сценарий**: Kafka собирает логи, RabbitMQ уведомляет о критических ошибках.

1. **Kafka**: Продюсер отправляет логи в топик logs.
2. **Kafka Consumer**: Читает логи, фильтрует критические ошибки.
3. **RabbitMQ Producer**: Отправляет уведомления в очередь alerts.
4. **RabbitMQ Consumer**: Обрабатывает уведомления (например, отправляет email).

**Код (упрощенно)**:

```go
// Kafka Consumer -> RabbitMQ Producer
func main() {
    // Kafka консюмер
    c, _ := kafka.NewConsumer(&kafka.ConfigMap{
        "bootstrap.servers": "localhost:9092",
        "group.id":          "log-group",
        "auto.offset.reset": "earliest",
    })
    c.SubscribeTopics([]string{"logs"}, nil)

    // RabbitMQ продюсер
    conn, _ := amqp091.Dial("amqp://guest:guest@localhost:5672/")
    ch, _ := conn.Channel()
    q, _ := ch.QueueDeclare("alerts", false, false, false, false, nil)

    // Обработка логов
    for {
        msg, err := c.ReadMessage(-1)
        if err == nil && string(msg.Value)[:5] == "ERROR" {
            // Отправка в RabbitMQ
            ch.Publish("", q.Name, false, false, amqp091.Publishing{
                Body: msg.Value,
            })
        }
    }
}
```

---

## Полезные команды

### Kafka

- Создать топик:
  ```bash
  kafka-topics --create --topic my-topic --bootstrap-server localhost:9092
  ```
- Просмотр сообщений:
  ```bash
  kafka-console-consumer --topic my-topic --from-beginning --bootstrap-server localhost:9092
  ```

### RabbitMQ

- Просмотр очередей:
  ```bash
  docker exec rabbitmq rabbitmqctl list_queues
  ```
- Очистка очереди:
  ```bash
  docker exec rabbitmq rabbitmqctl purge_queue my-queue
  ```

---

## Рекомендации

- **Kafka**:
  - Используйте Kafka Streams для потоковой обработки.
  - Настройте репликацию и партиции для отказоустойчивости.
  - Мониторьте с помощью Prometheus/Grafana.
- **RabbitMQ**:
  - Используйте Quorum Queues для высокой доступности.
  - Настройте плагины для MQTT/STOMP при необходимости.
  - Избегайте перегрузки очередей (TTL, max-length).
- **Go**:
  - Проверяйте ошибки в продакшен-коде.
  - Используйте контексты для graceful shutdown.
