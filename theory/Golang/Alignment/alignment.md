# Выравнивание памяти (Alignment) и Padding в Go

## 1. Что такое выравнивание (Alignment)

**Выравнивание** — это правило размещения данных в памяти, согласно которому значение определённого типа должно начинаться с адреса, кратного его **alignment**.

**Пример:**
- `int32` должен начинаться с адреса, кратного **4**.
- `int64` — кратного **8**.

> [!NOTE]
> Выравнивание напрямую связано с архитектурой процессора и влияет на корректность и производительность работы программы.

## 2. Зачем нужно выравнивание

### 2.1 Архитектура процессора
Процессор читает память не побайтово, а блоками фиксированного размера (словами). Если данные выровнены, требуется **одно чтение** памяти. Если нет — процессору приходится делать несколько чтений и «склеивать» результат, что замедляет работу.

### 2.2 Атомарные операции
Для многих процессоров атомарные операции (пакет `sync/atomic`) работают корректно **только** если данные выровнены по их размеру. На 32-битных архитектурах невыровненный `int64` вызовет панику при попытке атомарного доступа.
## 3. Что такое Padding

**Padding** — это пустые байты, которые компилятор автоматически вставляет между полями или в конце структуры, чтобы соблюсти требования выравнивания.

## 4. Выравнивание базовых типов (64-bit)

| Тип | Размер (байт) | Alignment |
| :--- | :---: | :---: |
| `bool`, `int8`, `uint8` | 1 | 1 |
| `int16`, `uint16` | 2 | 2 |
| `int32`, `uint32`, `float32` | 4 | 4 |
| `int64`, `uint64`, `float64`, `pointer` | 8 | 8 |
| `string` (структура из 2 полей) | 16 | 8 |
| `slice` (структура из 3 полей) | 24 | 8 |

> [!TIP]
> Размер типа и его выравнивание — это разные вещи. Например, `string` занимает 16 байт, но его **alignment** равен 8, так как самое большое поле внутри (указатель) требует выравнивания по 8 байтам.
## 5. Выравнивание структур (struct)

### 5.1 Основное правило
Каждое поле структуры должно начинаться с адреса, кратного его собственному **alignment**. Итоговый размер структуры также должен быть кратен её общему **alignment** (максимальному среди всех полей).

### 5.2 Пример: Неоптимальный порядок
```go
type Bad struct {
    a bool  // 1 байт
            // [7 байт padding]
    b int64 // 8 байт
} // Итого: 16 байт
```
**Память:** `[a][p][p][p][p][p][p][p] [b][b][b][b][b][b][b][b]`

### 5.3 Пример: Оптимальный порядок
```go
type Good struct {
    b int64 // 8 байт
    a bool  // 1 байт
            // [7 байт padding в конце]
} // Итого: 16 байт (но если добавить еще bool c, размер останется 16)
```

> [!IMPORTANT]
> **Правило большого пальца**: Располагайте поля в порядке убывания их размера. Это минимизирует количество вставляемого **padding**.
## 6. Продвинутые темы

### 6.1 Zero-sized types (Пустые типы)
Типы `struct{}` и `[0]int` имеют размер **0**. Однако у них есть особенность при размещении в структурах:

```go
type S1 struct {
    a struct{}
    b int64
} // Size: 8, 'a' не занимает места

type S2 struct {
    a int64
    b struct{}
} // Size: 16! (Padding добавлен в конце)
```

> [!WARNING]
> Если пустое поле является **последним** в структуре, компилятор добавляет **padding**, чтобы адрес этого поля не указывал на следующий объект в памяти (это важно для корректной работы GC).

### 6.2 Cache Line и False Sharing
Память читается из RAM в кэш процессора блоками по **64 байта** (**Cache Line**). 
- Если две горутины часто пишут в разные поля одной структуры, которые попали в одну кэш-линию, процессор будет постоянно сбрасывать кэш. Это называется **False Sharing**.
- Решение: добавить «пустые» поля (padding), чтобы разнести активные данные по разным кэш-линиям.

### 6.3 Проверка через `unsafe`
```go
import "unsafe"

fmt.Println(unsafe.Sizeof(s))   // Общий размер
fmt.Println(unsafe.Alignof(s))  // Выравнивание структуры
fmt.Println(unsafe.Offsetof(s.b)) // Смещение поля 'b' от начала
```

---

## Итог: Практические советы
1. **Группируйте поля**: от больших к малым (`int64` -> `int32` -> `bool`).
2. **Следите за хвостом**: не ставьте `struct{}` последним полем, если важен минимальный размер.
3. **Атомики**: убедитесь, что переменные для `sync/atomic` выровнены по 8 байт.
4. **Инструменты**: используйте линтеры (например, `fieldalignment`), чтобы автоматически находить лишний padding.