### Что такое map?

# `map` в Go 1.24 (Swiss Tables)

## Введение

`map` в Go 1.24 использует дизайн **Swiss Tables**, который заменил старую bucket-based реализацию. Это делает `map`быстрее (поиск на 20–50%, вставка на 15–30%) и экономичнее по памяти (на 20–28%). API не изменился, код работает как раньше.

## Устройство `map`

- **hmap**: Главная структура, управляющая `map`.
  ```go
  type hmap struct {
      count  int   // Количество элементов
      hash0  uint32 // Случайное число для хеширования
      tables unsafe.Pointer // Указатель на массив таблиц
      // ... другие поля для роста
  }
  ```
- **tables**: Массив групп
- **Группа (group)**: Содержит:
  - **8 слотов**: Для пар ключ-значение (например, ключ `"apple"`, значение `5`).
  - **Control word**: 8 байт, каждый описывает слот:
    - **`empty`**: Слот пустой.
    - **`full`**: Слот занят, хранит **H2** (7-битный отпечаток хеша).
    - **`deleted`**: Слот был занят, но удалён.
    - **`probe`**: Ищи дальше в следующей группе.
  - Пример группы:
    ```
    Control word: [82, 45, empty, empty, deleted, 90, empty, probe]
    Slots:
      Слот 0: [ключ: "apple", значение: 5]  // H2 = 82
      Слот 1: [ключ: "banana", значение: 10]  // H2 = 45
      ...
    ```

## Хеширование

- Хеш ключа делится на две части:
  - **H1**: Указывает на группу (например, **H1** = 2 → группа 2).
  - **H2**: 7-битный отпечаток хеша (например, `82`), хранится в **`control word`** для занятых слотов.
- **Линейное пробирование**: Если группа полная или ключ не найден, Go проверяет следующую группу.

## Операции

### Поиск (`value, ok := m["apple"]`)

1. Хеш `"apple"` → H1 = 2 (группа 2), H2 = 82.
2. Смотрим `control word` группы 2:
   - Если H2 = 82, проверяем ключ в слоте.
   - Если `empty`, останавливаемся (ключа нет).
   - Если `deleted` или `probe`, ищем дальше (следующая группа).
3. Если ключ совпал, возвращаем значение и `ok = true`. Иначе `ok = false`.

> [!IMPORTANT]
> **Почему останавливаемся на `empty`?**
> При открытой адресации ключ бы занял пустой слот. Если видим **`empty`**, значит ключа нет.

### Вставка (`m["apple"] = 5`)

1. Хеш `"apple"` → H1 = 2, H2 = 82.
2. Смотрим `control word` группы 2:
   - Если есть `empty` или `deleted`, кладём ключ-значение в слот, обновляем `control word` (например, `control word[0] = 82`).
   - Если группа полная, ставим `probe` в `control word[7]` и идём в следующую группу.
3. Если мест нет, Go **расщепляет** таблицу.

### Удаление (`delete(m, "apple")`)

1. Хеш `"apple"` → H1 = 2, H2 = 82.
2. Смотрим `control word` группы 2:
   - Если H2 = 82 и ключ совпал, ставим `control word[i] = deleted`.
   - Если `empty`, останавливаемся (ключа нет).
   - Если `deleted` или `probe`, ищем дальше.
3. Иногда Go делает компакцию (перемещает элементы, чтобы убрать `deleted`).

## Роль `empty`, `deleted`, `probe`

- **`empty`**: Пустой слот. При поиске/удалении — ключа нет, останавливаемся. При вставке — используем этот слот.
- **`deleted`**: Слот был занят, но удалён. При поиске — ищем дальше. При вставке — можем использовать этот слот.
- **`probe`**: Ставится в последнем байте `control word` полной группы, чтобы сказать: "ищи в следующей группе".

## Расщепление таблицы

- Если группы заполнены, Go создаёт новую таблицу (например, в 2 раза больше).
- Переполненная группа делится на две (например, группа 2 → группы 2 и 10).
- Ключи перераспределяются по H1/H2, память выделяется для новой таблицы.
- Остальные группы копируются без изменений.

## Преимущества Go 1.24

- **Скорость**: Поиск на 20–50% быстрее, вставка на 15–30% (благодаря **`control word`**, **SIMD**, **линейному пробированию**).
- **Память**: Экономия 20–28% (нет **overflow buckets**, компактные группы).
- **Кэш-локальность**: Данные лежат ближе, меньше кэш-миссов.
- **Локальный рост**: Расщепление вместо полного перехеширования.

## Пример кода

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    m := make(map[string]int)
    n := 1_000_000

    // Вставка
    start := time.Now()
    for i := 0; i < n; i++ {
        m[fmt.Sprintf("key%d", i)] = i
    }
    fmt.Printf("Вставка %d элементов: %v\n", n, time.Since(start))

    // Поиск
    start = time.Now()
    for i := 0; i < n; i++ {
        _ = m[fmt.Sprintf("key%d", i)]
    }
    fmt.Printf("Поиск %d элементов: %v\n", n, time.Since(start))

    // Удаление
    start = time.Now()
    for i := 0; i < n; i++ {
        delete(m, fmt.Sprintf("key%d", i))
    }
    fmt.Printf("Удаление %d элементов: %v\n", n, time.Since(start))
}
```

## Сравнение со старой `map` (до 1.24)

- **Старая**: **Buckets** (корзины) с **overflow buckets**, полное перехеширование при росте, больше памяти, хуже кэш-локальность.
- **Новая**: Группы, линейное пробирование, локальное расщепление, поддержка **SIMD**, меньше памяти.

# **map** < Go 1.24 (**Overflow buckets**)

**map** — это встроенный тип данных в Go, представляющий **хэш-таблицу**. Это структура для хранения пар "ключ-значение" (**key-value**), которая обеспечивает быстрые операции:

- Добавление (m["key"] = value).

- Поиск (value := m["key"]).

- Удаление (delete(m, "key")).

В идеале операции выполняются за O(1) — константное время. Пример:

```Go
m := make(map[string]int)
m["apple"] = 5
m["banana"] = 3
fmt.Println(m["apple"]) // 5
```

---

### Что под капотом map?

Внутри `map` реализован как структура **hmap** (hash map) в runtime Go. Вот её упрощённое представление:

```go
type hmap struct {
    count     int       // Количество элементов
    B         uint8     // Логарифм размера массива бакетов (2^B)
    buckets   []bmap    // Массив бакетов
    oldbuckets []bmap   // Старый массив бакетов (при росте)
    hash0     uint32    // Начальное значение для хэш-функции (seed)
}
```

- **count**: Сколько пар "ключ-значение" в таблице.
- **B**: Размер массива бакетов как степень двойки ($2^B$). Например, $B = 3 \to 8$ бакетов.
- **buckets**: Срез, указывающий на массив бакетов.
- **oldbuckets**: Используется при эвакуации.
- **hash0**: Случайный **seed** для защиты от коллизий.

---

### Что такое хэш-функция?

Хэш-функция — это алгоритм, который превращает ключ в число (**хэш**). Она определяет, в какой **бакет** попадёт ключ.

> [!TIP]
> Go использует разные хэш-функции для разных типов (например, **aeshash** для строк), оптимизированные под архитектуру процессора.

### Как работает хэш-функция в Go?

- **Зависит от типа ключа**: Go использует разные хэш-функции для разных типов:
  - Для строк: алгоритм вроде aeshash (быстрый и оптимизированный для процессоров с AES).
  - Для чисел: простые побитовые операции.
  - Для структур: комбинация хэшей полей.

- **Случайность**: hash0 (seed) добавляется к вычислениям, чтобы хэши менялись между запусками программы, защищая от атак на коллизии.

- **Результат**: Хэш — это большое число (например, 64-битное), из которого берутся биты для вычисления индекса бакета.

Пример:

- "apple" → хэш-функция → 123456789.

- "banana" → хэш-функция → 987654321.

### Как выбирается бакет?

- Размер массива бакетов — степень двойки (например, 8 = 2³).

- Берутся младшие биты хэша, соответствующие B. Для 8 бакетов — 3 бита:
  - 123456789 → ...101 → бакет 5.
  - 987654321 → ...001 → бакет 1.

---

### Что такое бакеты (buckets)?

Бакеты — это элементы массива buckets. Каждый бакет — контейнер для хранения до 8 пар "ключ-значение", реализованный как bmap.

### Что под капотом бакета?

- **tophash**: Массив из 8 байтов, где каждый байт — верхние 8 бит хэша ключа. Ускоряет поиск.

- **Ключи и значения**: Следуют в памяти после tophash. Например, для map[string]int:
  - 8 строк (указателей).
  - 8 чисел int.

- **overflow**: Указатель на дополнительный бакет при переполнении.

Пример памяти:

```Go
bmap {
    tophash:  [8]uint8    // 8 байт
    keys:     [8]string   // 64 байта (8 указателей)
    values:   [8]int      // 64 байта (8 чисел)
    overflow: *bmap       // 8 байт
}
```

### Как заполняется бакет?

- Хэш → индекс бакета → пара добавляется в свободный слот (до 8).

- Если слотов больше нет → создаётся overflow-бакет.

- Ключ есть → обновляем значение.

---

### Операции с map

1. **Добавление** (m["apple"] = 5):
   - Хэш-функция: "apple" → 123456789 → бакет 5.
   - В бакете 5:
     - Меньше 8 пар → добавляем "apple": 5.
     - 8 пар → overflow-бакет.
     - Ключ есть → обновляем значение.

2. **Поиск** (m["apple"]):
   - Хэш → бакет 5.
   - Смотрим tophash → находим совпадение → сравниваем ключ → возвращаем 5.
   - Нет ключа → 0.

3. **Удаление** (delete(m, "apple")):
   - Хэш → бакет 5.
   - Находим ключ → помечаем слот пустым.

---

### Коллизии

**Коллизия**: Когда два ключа попадают в один бакет из-за одинакового индекса.

- Пример: "apple" и "banana" → бакет 5.

### Как решают?

1. **До 8 пар**:
   - Хранятся в одном бакете: ["apple": 5, "banana": 3].
   - Поиск: tophash → побайтовое сравнение.

2. **Больше 8 пар**:
   - Создаётся overflow-бакет.
   - Пример: бакет 5 (8 пар) → overflow ("orange": 7).

Хэш-функция старается минимизировать коллизии, равномерно распределяя ключи.

---

### Эвакуация

> [!NOTE]
> **Эвакуация** — это постепенный процесс переноса элементов в новые бакеты при росте таблицы.

#### Когда?
1. **Load factor > 6.5**: Отношение элементов к бакетам слишком велико.
2. **Много overflow-бакетов**: Ухудшение производительности из-за коллизий.

#### Как?
- Число бакетов удваивается ($B \to B+1$).
- **Ленивая эвакуация**: Элементы переносятся по частям во время записи или удаления.
- Старые данные временно хранятся в **oldbuckets**.

---

### Почему быстро?
- **Хэш-функция**: Быстрая и равномерная.
- **Бакеты**: 8 пар — оптимально для кэш-линий процессора.
- **Эвакуация**: Ленивая («размазанная» во времени), не вызывает длинных пауз.
