### Что такое map?

**map** — это встроенный тип данных в Go, представляющий **хэш-таблицу**. Это структура для хранения пар "ключ-значение" (**key-value**), которая обеспечивает быстрые операции:
- Добавление (`m["key"] = value`).
- Поиск (`value := m["key"]`).
- Удаление (`delete(m, "key")`).

В идеале операции выполняются за O(1) — константное время.

---

# 1. Традиционная реализация (`map` < Go 1.24)

До версии 1.24 Go использовал классическую архитектуру хэш-таблицы на основе **бакетов** и **overflow-цепочек**.

## Устройство `map` (hmap)

Внутри `map` реализован как структура **hmap** (hash map) в runtime Go:

```go
type hmap struct {
    count     int       // Количество элементов
    B         uint8     // Логарифм размера массива бакетов (2^B)
    buckets   []bmap    // Массив бакетов
    oldbuckets []bmap   // Старый массив бакетов (при росте)
    hash0     uint32    // Начальное значение для хэш-функции (seed)
}
```

- **count**: Сколько пар "ключ-значение" в таблице.
- **B**: Размер массива бакетов как степень двойки ($2^B$). Например, $B = 3 \to 8$ бакетов.
- **buckets**: Срез, указывающий на массив бакетов.
- **oldbuckets**: Используется при эвакуации.
- **hash0**: Случайный **seed** для защиты от коллизий.

### Хеширование и выбор бакета

1. **Хэш-функция**: Превращает ключ в 64-битное число. Go использует оптимизированные функции (например, **aeshash** для строк).
2. **Случайность**: `hash0` добавляется к вычислениям, чтобы хэши менялись между запусками (защита от коллизий).
3. **Индекс бакета**: Берутся младшие биты хэша. Для 8 бакетов ($B=3$) — последние 3 бита.
   - `123456789 → ...101 → бакет 5`.

## Устройство бакета (bmap)

Каждый бакет — контейнер для хранения до **8 пар** "ключ-значение".

```go
bmap {
    tophash:  [8]uint8    // Верхние 8 бит хэша для быстрого поиска
    keys:     [8]string   // 8 ключей
    values:   [8]int      // 8 значений
    overflow: *bmap       // Указатель на следующий бакет (при переполнении)
}
```

- **tophash**: Позволяет быстро отсеять ключи, не выполняя полное сравнение.
- **Ключи и значения**: Хранятся раздельно (сначала все 8 ключей, потом все 8 значений), чтобы минимизировать padding в памяти.

### Коллизии и Overflow

Если в бакет попадает более 8 элементов, создается **overflow-бакет**, который прикрепляется к текущему цепочкой. Это делает поиск медленнее ($O(N)$ в худшем случае для одной цепочки).

## Рост и Эвакуация

> [!NOTE]
> **Эвакуация** — это постепенный перенос элементов в новые бакеты при увеличении таблицы.

1. **Когда?**: 
   - Load factor > 6.5 (в среднем больше 6.5 элементов на бакет).
   - Слишком много overflow-бакетов.
2. **Как?**: 
   - Создается новый массив бакетов в 2 раза больше ($B+1$).
   - **Ленивая эвакуация**: Элементы переносятся частями во время записи или удаления, чтобы не блокировать программу надолго.

---

# 2. Новая реализация (`map` Go 1.24+)

Начиная с Go 1.24, используется дизайн **Swiss Tables**. Это кардинальное изменение, которое делает `map` значительно эффективнее.

## Что изменилось?

Вместо бакетов теперь используются **Группы (Groups)** и **Swiss Tables** алгоритмы.

- **hmap**: Главная структура теперь управляет таблицами групп.
- **Группа (group)**: Содержит **8 слотов** и специальное **Control word** (8 байт).
- **Control word**: Хранит 7-битные отпечатки хешей (**H2**) или статусы слотов (`empty`, `deleted`).

### Почему это быстрее?

1. **SIMD**: Go проверяет наличие нужного хеша во всей группе (8 слотов) за **одну инструкцию процессора**.
2. **Кэш-локальность**: Нет цепочек overflow-бакетов. Данные лежат плотнее в памяти.
3. **Линейное пробирование**: Если группа полная, мы просто идем к следующей соседней группе.

## Операции в Swiss Tables

### Поиск
1. Хеш разбивается на **H1** (указывает на группу) и **H2** (7-битный отпечаток).
2. С помощью **SIMD** ищем **H2** в `control word` группы.
3. Если нашли совпадение — проверяем сам ключ.
4. Если встретили статус `empty` — ключа точно нет.

### Удаление
Вместо того чтобы просто очистить слот, он помечается как `deleted`. Это важно для линейного пробирования, чтобы поиск не обрывался раньше времени.

---

## Сравнение реализаций

| Характеристика | Традиционная (до 1.24) | Swiss Tables (1.24+) |
| :--- | :--- | :--- |
| **Структура** | Бакеты + Overflow buckets | Компактные группы |
| **Поиск** | Линейный обход бакета | **SIMD** проверка группы |
| **Коллизии** | Цепочки (chaining) | Линейное пробирование |
| **Производительность** | Средняя | **+20-50%** к скорости поиска |
| **Память** | Больше (padding, overflow) | **-20-28%** потребления |

---

## Пример использования (API не изменилось)

```go
package main

import "fmt"

func main() {
    // Создание
    m := make(map[string]int, 10) // 10 - начальная емкость

    // Запись
    m["Go"] = 2009

    // Чтение (запятая-ok)
    val, ok := m["Go"]
    if ok {
        fmt.Println("Found:", val)
    }

    // Удаление
    delete(m, "Go")
}
```
