package array

/*
Slice (Срез)

Что это такое?
Срез в Go — это дескриптор (описатель) непрерывного сегмента массива. В отличие от массива, срез имеет динамический размер.
Это основная структура данных для работы с последовательностями в Go.

Зачем это нужно?
- Гибкая работа с коллекциями данных (изменение размера, добавление элементов).
- Эффективная передача данных в функции (передается только заголовок среза, а не данные).
- Возможность создавать "окна" (views) на части массива без копирования.

В чём смысл?
- Under the hood это структура из 3 полей:
  1. Pointer: указатель на начало сегмента в базовом массиве.
  2. Length (len): количество элементов в срезе.
  3. Capacity (cap): емкость (сколько элементов поместится без перевыделения памяти).

Когда использовать?
- Почти всегда, когда вам нужен список элементов.
- Когда количество элементов заранее неизвестно.
- Для работы с буферами данных, строками (как []byte) и коллекциями.

Как работает?
- `append()` добавляет элементы. Если capacity не хватает, Go создает новый массив большего размера (обычно x2) и копирует туда данные.
- Срезы дешевы для передачи: копируются только 3 машинных слова (ptr, len, cap).

Сложность:
- Доступ по индексу: O(1)
- Append: Amortized O(1) (иногда O(n) при реаллокации)
- Slicing (получение подсреза): O(1)
*/

func SliceExamples() {
	// 1. Создание среза
	var slice1 []int            // nil срез (ptr=nil, len=0, cap=0)
	slice2 := []int{1, 2, 3}    // Литерал (создает скрытый массив + срез)
	slice3 := make([]int, 3)    // make([]T, len) -> [0 0 0]
	slice4 := make([]int, 2, 5) // make([]T, len, cap) -> len=2, cap=5

	// 2. Slicing (создание среза из массива или другого среза)
	arr := [5]int{1, 2, 3, 4, 5}
	subSlice := arr[1:4] // [2 3 4] - указывает на т тот же массив!

	// 3. Добавление элементов (Append)
	slice2 = append(slice2, 4)    // [1 2 3 4]
	slice2 = append(slice2, 5, 6) // [1 2 3 4 5 6]

	// 4. Копирование (Copy)
	// copy(dst, src) копирует min(len(dst), len(src)) элементов
	sliceCopy := make([]int, len(slice2))
	copy(sliceCopy, slice2)

	// Характеристики
	_ = len(slice2) // Текущая длина
	_ = cap(slice2) // Емкость базового массива от начала указателя

	// Чтобы компилятор не ругался
	_, _, _, _, _ = slice1, slice3, slice4, subSlice, sliceCopy
}

/*
Важно помнить (Gotchas):
1. Срезы ссылаются на базовый массив. Изменение элемента в одном срезе может повлиять на другой, если они "смотрят" на одну память.
2. Утечки памяти: если маленький срез ссылается на огромный массив, сборщик мусора не удалит весь массив, пока жив срез.
*/
