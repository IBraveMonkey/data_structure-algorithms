package strings

/* Метод грубой силы или метод прямого перебора(Brute force)

- Начинаем с первого символа в строке
- Сравниваем слева направо каждый
	символ из строки с подстрокой
- Если совпадение не найдено, смещаем
	позицию поиска в строке на один символ вправо и повторяем сравнения до конца строки
- Запоминаем все позиций, в которых было полное
	совпадение с подстрокой
*/

/*
	a - exampletext, b - ext , например вернуть индекс строки, где она начинается, тут будет - 8

timeComplexity - 0(n * m), где n - длина строки, а m - длина подстроки
spaceComplexity - O(1)
*/
func BruteForce(text, pattern string) int {
	tRune := []rune(text)    // Длина исходной строки // 11
	pRune := []rune(pattern) // Длина подстроки // 3

	n := len(tRune)
	m := len(pRune)

	for i := 0; i <= n-m; i++ { // Перебираем все возможные позиций // 8
		j := 0

		for j < m && tRune[i+j] == pRune[j] { // Проверяем символы один за другим
			j++
		}

		if j == m { // Если мы проверили всю подстроку и она совпала
			return i
		}
	}

	return -1 // Если не нашли подстроку
}

/* Алгоритм Бойера - Мура - Хорспула
	Обычный метод грубой силы проверяет каждый символ по порядку.
	Но Бойер-Мур-Хорспул использует "умные прыжки", чтобы не проверять лишнее.

	Главная идея: если нашли несовпадение, не сдвигаем на 1 символ, а сразу перескакиваем дальше по тексту.

	Берем все символы подстроки, кроме последнего и записываем для каждого, какой сделать сдвиг:
		e → 2 (до конца подстроки 2 символа)
		x → 1 (до конца подстроки 1 символ)
		Последний символ "t" получает сдвиг по умолчанию m = 3 (длина подстроки).

	Таблица сдвигов:
	'e' → 2
	'x' → 1
	't' → 3 (по умолчанию, так как последний)

timeComplexity - O(n * m)

spaceComplexity - O(m), где m - длина подстроки
*/

func createShiftTable(pattern string) map[byte]int {
	m := len(pattern)
	table := make(map[byte]int)

	for i := 0; i < m-1; i++ {
		table[pattern[i]] = m - 1 - i
	}

	return table
}

func BMHSearch(text, pattern string) int {
	n, m := len(text), len(pattern)
	if m > n {
		return -1
	}

	shiftTable := createShiftTable(pattern)
	i := 0

	for i <= n-m {
		j := m - 1

		for j >= 0 && text[i+j] == pattern[j] {
			j--
		}

		if j < 0 {
			return i
		}

		shift, exists := shiftTable[text[i+m-1]]
		if exists {
			i += shift
		} else {
			i += m
		}
	}

	return -1
}

/* Алгоритм Рабина - Карпа

 */
