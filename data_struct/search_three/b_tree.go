package search_three

import (
	"container/list"
	"fmt"
)

/* Бинарное дерево поиска (BST):
- Это разновидность деревьев, где каждый узел имеет не более двух потомков: левый и правый.
- Особенность BST: для каждого узла все значения в левом поддереве меньше значения узла, а в правом — больше.
- Преимущество: меньшее количество проверок при рекурсивном обходе, так как у узла может быть от 0 до 2 детей.
- Сложность основных операций (вставка, поиск, удаление) в среднем составляет O(log n), если дерево сбалансировано.
- Используется для быстрого поиска, сортировки и управления упорядоченными данными.
*/

// Node — структура, представляющая узел бинарного дерева поиска
type Node struct {
	Value int   // Значение, хранимое в узле
	Left  *Node // Указатель на левое поддерево (значения меньше текущего)
	Right *Node // Указатель на правое поддерево (значения больше текущего)
}

// NewNode — создаёт новый узел с заданным значением
func NewNode(value int) *Node {
	return &Node{Value: value} // Инициализирует узел с указанным значением, Left и Right остаются nil
}

// Insert — вставляет новое значение в бинарное дерево поиска
func (n *Node) Insert(value int) *Node {
	// Если текущий узел пуст (nil), создаём новый узел с заданным значением
	if n == nil {
		return NewNode(value)
	}

	// Если новое значение меньше текущего, рекурсивно вставляем в левое поддерево
	if value < n.Value {
		n.Left = n.Left.Insert(value)
	} else if value > n.Value {
		// Если больше — рекурсивно вставляем в правое поддерево
		n.Right = n.Right.Insert(value)
	}
	// Дубликаты (value == n.Value) игнорируются в этой реализации

	return n // Возвращаем текущий узел для поддержки цепочки вызовов
}

// Search — ищет узел с заданным значением в BST
func (n *Node) Search(value int) *Node {
	// Если узел пустой или значение найдено, возвращаем текущий узел
	if n == nil || n.Value == value {
		return n // nil — значение не найдено, иначе возвращаем узел
	}

	// Если искомое значение меньше текущего, продолжаем поиск в левом поддереве
	if value < n.Value {
		return n.Left.Search(value)
	}

	// Если больше — продолжаем поиск в правом поддереве
	return n.Right.Search(value)
}

/*
	Обход в ширину (Breadth-First Search, BFS):

- Метод обхода дерева по уровням: сначала обрабатывается корень, затем все узлы следующего уровня слева направо и так далее.
- Использует очередь для хранения узлов, которые нужно обработать.
- Подходит для задач, где важен порядок обработки по уровням, например, для поиска кратчайшего пути в невзвешенном графе.
- Сложность: O(n), где n — количество узлов в дереве.
*/
func (n *Node) BFS() {
	// Если дерево пустое, ничего не делаем
	if n == nil {
		return
	}

	queue := list.New() // Создаём очередь для хранения узлов (FIFO — первый вошёл, первый вышел)
	queue.PushBack(n)   // Добавляем корень как первый элемент очереди

	// Пока очередь не пуста, обрабатываем узлы
	for queue.Len() > 0 {
		element := queue.Front()      // Берём первый элемент из очереди
		node := element.Value.(*Node) // Приводим значение к типу *Node
		queue.Remove(element)         // Удаляем обработанный элемент из очереди

		fmt.Print(node.Value, " ") // Выводим значение текущего узла

		// Добавляем левого ребёнка в очередь, если он существует
		if node.Left != nil {
			queue.PushBack(node.Left)
		}
		// Добавляем правого ребёнка в очередь, если он существует
		if node.Right != nil {
			queue.PushBack(node.Right)
		}
	}
}

/*
	Обход в глубину (Depth-First Search, DFS):
- Метод обхода дерева, при котором сначала исследуется максимальная глубина ветви, затем возвращение назад.
- Использует неявный стек (через рекурсию) с принципом LIFO (последний вошёл, первый вышел).
- В BST поддерживает три варианта: PreOrder, InOrder, PostOrder, отличающиеся порядком обработки узлов.
*/

// InOrder — симметричный обход дерева в порядке "лево -> корень -> право"
func (n *Node) InOrder() {
	// Если узел пустой, прерываем рекурсию
	if n == nil {
		return
	}

	n.Left.InOrder()        // Сначала обходим левое поддерево
	fmt.Print(n.Value, " ") // Затем выводим значение текущего узла (дает отсортированный порядок для BST)
	n.Right.InOrder()       // Затем обходим правое поддерево
}

// PreOrder — обход дерева в порядке "корень -> лево -> право"
func (n *Node) PreOrder() {
	// Если узел пустой, прерываем рекурсию
	if n == nil {
		return
	}

	fmt.Print(n.Value, " ") // Сначала выводим значение текущего узла
	n.Left.PreOrder()       // Затем обходим левое поддерево
	n.Right.PreOrder()      // Затем обходим правое поддерево
}

// PostOrder — обход дерева в порядке "лево -> право -> корень"
func (n *Node) PostOrder() {
	// Если узел пустой, прерываем рекурсию
	if n == nil {
		return
	}

	n.Left.PostOrder()      // Сначала обходим левое поддерево
	n.Right.PostOrder()     // Затем обходим правое поддерево
	fmt.Print(n.Value, " ") // В конце выводим значение текущего узла
}

// minValueNode — находит узел с минимальным значением в поддереве
func (n *Node) minValueNode() *Node {
	current := n
	// Идём влево до самого левого узла, где находится минимальное значение
	for current.Left != nil {
		current = current.Left
	}
	return current // Возвращаем узел с минимальным значением
}

// maxValueNode — находит узел с максимальным значением в поддереве
func (n *Node) maxValueNode() *Node {
	current := n
	// Идём вправо до самого правого узла, где находится максимальное значение
	for current.Right != nil {
		current = current.Right
	}
	return current // Возвращаем узел с максимальным значением
}

/*
	Удаление узла из BST:

- Процесс удаления зависит от количества потомков у удаляемого узла:
 1. Узел без потомков (лист): просто убираем его, возвращая nil.
 2. Узел с одним потомком: заменяем узел на этого потомка.
 3. Узел с двумя потомками: заменяем его минимальным значением из правого поддерева (преемником) и удаляем преемника.

- Сложность: O(log n) в среднем, если дерево сбалансировано.
*/
func (n *Node) Delete(value int) *Node {
	// Если узел пустой, возвращаем nil (ничего не удаляем)
	if n == nil {
		return nil
	}

	// Ищем узел для удаления
	if value < n.Value {
		n.Left = n.Left.Delete(value) // Рекурсивно идём в левое поддерево
	} else if value > n.Value {
		n.Right = n.Right.Delete(value) // Рекурсивно идём в правое поддерево
	} else { // Найден узел для удаления
		// Случай 1: узел без потомков (лист)
		if n.Left == nil && n.Right == nil {
			return nil // Обрываем ссылку на узел
		}

		// Случай 2: узел с одним потомком
		if n.Left == nil {
			return n.Right // Заменяем узел на правого ребёнка
		}
		if n.Right == nil {
			return n.Left // Заменяем узел на левого ребёнка
		}

		// Случай 3: узел с двумя потомками
		minRight := n.Right.minValueNode()       // Находим минимальный узел в правом поддереве (преемник)
		n.Value = minRight.Value                 // Копируем значение преемника в текущий узел
		n.Right = n.Right.Delete(minRight.Value) // Удаляем преемника из правого поддерева
	}

	return n // Возвращаем обновлённый узел
}

// MinDepth — вычисляет минимальную глубину дерева с помощью DFS
func MinDepth(root *Node) int {
	// Если дерево пустое, глубина равна 0
	if root == nil {
		return 0
	}

	// Если нет левого поддерева, считаем глубину только по правому
	if root.Left == nil {
		return 1 + MinDepth(root.Right)
	}

	// Если нет правого поддерева, считаем глубину только по левому
	if root.Right == nil {
		return 1 + MinDepth(root.Left)
	}

	// Если есть оба поддерева, выбираем меньшую глубину и добавляем 1 (текущий уровень)
	return 1 + min(MinDepth(root.Left), MinDepth(root.Right))
}

// min — вспомогательная функция для выбора меньшего из двух чисел
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// IsSameTree — проверяет, являются ли два дерева идентичными
func IsSameTree(p *Node, q *Node) bool {
	// Если оба узла пустые, деревья считаются одинаковыми
	if p == nil && q == nil {
		return true
	}

	// Если один узел пустой, а другой нет, деревья разные
	if p == nil || q == nil {
		return false
	}

	// Если значения текущих узлов не совпадают, деревья разные
	if p.Value != q.Value {
		return false
	}

	// Рекурсивно проверяем идентичность левых и правых поддеревьев
	return IsSameTree(p.Left, q.Left) && IsSameTree(p.Right, q.Right)
}

// main — пример использования для тестирования функциональности BST
func main() {
	// Инициализируем пустое дерево
	var root *Node
	values := []int{10, 5, 15, 3, 7, 12, 18}
	for _, v := range values {
		root = root.Insert(v) // Вставляем значения в BST
	}

	// Выводим дерево разными способами
	fmt.Println("PreOrder (корень -> лево -> право):")
	root.PreOrder()
	fmt.Println("\nInOrder (лево -> корень -> право, отсортировано):")
	root.InOrder()
	fmt.Println("\nPostOrder (лево -> право -> корень):")
	root.PostOrder()
	fmt.Println("\nBFS (по уровням):")
	root.BFS()
	fmt.Println()

	// Тестируем поиск
	fmt.Println("Поиск 7:", root.Search(7).Value) // Ожидаем 7
	if root.Search(9) == nil {
		fmt.Println("9 не найдено")
	}

	// Тестируем удаление
	fmt.Println("Удаляем 5...")
	root = root.Delete(5)
	fmt.Println("InOrder после удаления:")
	root.InOrder()
	fmt.Println()

	// Проверяем минимальную глубину
	fmt.Println("Минимальная глубина дерева:", MinDepth(root))
}
