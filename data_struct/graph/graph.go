/*
Graph (Граф)

Что это такое?
Граф — это абстрактная структура данных, представляющая собой множество вершин (узлов) и набор ребер (связей), соединяющих пары вершин.
Графы используются для моделирования объектов и отношений между ними.

Зачем это нужно?
- Моделирование сетей (социальные сети, интернет, дорожные карты).
- Решение задач маршрутизации (поиск кратчайшего пути).
- Анализ зависимостей (компиляция кода, планирование задач).

В чём смысл?
- Вершины (Nodes/Vertices) представляют объекты.
- Ребра (Edges) представляют связи между объектами.
- Графы могут быть направленными (орграфы) и ненаправленными, взвешенными (ребра имеют вес) и невзвешенными.

Когда использовать?
- Когда есть объекты и сложные связи между ними.
- поиск путей (навигаторы, игры).
- Анализ связности (кто с кем знаком, какие компьютеры соединены).
- Топологическая сортировка (порядок выполнения зависимых задач).

Как работает?
- Существует два основных способа представления графа:
  1. Матрица смежности (Adjacency Matrix): двумерный массив, где array[i][j] показывает наличие связи. Эффективно для плотных графов.
  2. Список смежности (Adjacency List): массив списков/map, где для каждой вершины хранится список её соседей. Эффективно для разреженных графов.

Как понять, что задача подходит под Graph?
- Задача про города и дороги, компьютеры и кабели, друзей и знакомства.
- Нужно найти кратчайший путь или количество способов добраться из A в B.
- Нужно проверить, связаны ли объекты.
*/

package graph

import "fmt"

// Graph представляет граф через список смежности (Adjacency List)
// Это наиболее универсальный способ представления для большинства алгоритмических задач.
type Graph struct {
	adjList map[int][]int
}

// NewGraph создает новый граф
func NewGraph() *Graph {
	return &Graph{adjList: make(map[int][]int)}
}

// AddEdge добавляет ребро (u, v)
// Для ненаправленного графа ребро добавляется в обе стороны.
func (g *Graph) AddEdge(u, v int) {
	// Добавляем v в список смежности u
	g.adjList[u] = append(g.adjList[u], v)
	// Добавляем u в список смежности v (так как граф ненаправленный)
	g.adjList[v] = append(g.adjList[v], u)
}

// Print выводит структуру графа
func (g *Graph) Print() {
	for node, neighbors := range g.adjList {
		fmt.Printf("%d -> %v\n", node, neighbors)
	}
}
