package genarator

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

/*
 * Паттерн Generator (Генератор) используется для создания функций, которые возвращают канал и генерируют значения для этого канала.
 * Он позволяет создавать потоки данных, которые могут быть использованы другими частями программы.
 * Пример использования: генерация последовательности чисел, которая может быть использована для обработки в других горутинах.
 */

// randomTimeWork имитирует работу, которая занимает случайное количество времени (до 100 секунд)
func randomTimeWork() {
	// Генерируем случайное число от 0 до 99 и умножаем на секунду
	time.Sleep(time.Duration(rand.Intn(100)) * time.Second)
}

// PredictableTimeWork демонстрирует, как ограничить время выполнения функции
// Как сделать чтобы функция работало только какое-то время - 3s
func PredictableTimeWork() {
	// Создаем канал для сигнала завершения работы
	ch := make(chan struct{})

	// Запускаем горутину, которая выполнит работу и закроет канал
	go func() {
		randomTimeWork()          // Выполняем работу (может быть длительной)
		close(ch)                  // Закрываем канал, сигнализируя о завершении
	}()

	// Ждем либо завершения работы, либо таймаута
	select {
	case <-ch:
		// Работа завершилась до истечения таймаута
		fmt.Println("Done")
	case <-time.After(3 * time.Second):
		// Прошло 3 секунды, прерываем ожидание
		fmt.Println("Cancel with timeout")
	}
}

// writer — это генератор, который создает канал и возвращает его
// Микропаттерн - Генератор, который создает канал и возращает его
func writer() <-chan int {
	// Создаем канал для передачи целых чисел
	ch := make(chan int)
	// Создаем WaitGroup для ожидания завершения всех горутин
	wg := &sync.WaitGroup{}

	// Добавляем 2 горутины в счетчик
	wg.Add(2)

	// Первая горутина: отправляет числа от 1 до 5
	// Должна быть не блокируемой, надо делать в отдельной горутине
	go func() {
		defer wg.Done()           // Уменьшаем счетчик при завершении функции
		for i := range 5 {        // Итерируемся от 0 до 4
			ch <- i + 1           // Отправляем числа 1, 2, 3, 4, 5 в канал
		}
	}()

	// Вторая горутина: отправляет числа от 11 до 15
	go func() {
		defer wg.Done()           // Уменьшаем счетчик при завершении функции
		for i := range 5 {        // Итерируемся от 0 до 4
			ch <- i + 11          // Отправляем числа 11, 12, 13, 14, 15 в канал
		}
	}()

	// Третья горутина: ждет завершения всех горутин и закрывает канал
	go func() {
		wg.Wait()                 // Блокируется до тех пор, пока счетчик не станет 0
		close(ch)                 // Закрываем канал после того, как все данные отправлены
	}()

	// Возвращаем канал только для чтения (безопасность)
	return ch
}

// Generator демонстрирует использование паттерна Генератор
func Generator() {
	// Получаем канал от генератора
	ch := writer()

	// Читаем все значения из канала до его закрытия
	for v := range ch {
		fmt.Println("v =", v)    // Выводим каждое полученное значение
	}
}
