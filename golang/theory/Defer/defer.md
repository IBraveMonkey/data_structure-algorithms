# Defer в Go: Полное руководство

`defer` — это ключевое слово в Go, которое откладывает выполнение функции до тех пор, пока окружающая функция не завершится (либо через `return`, либо из-за паники).

---

## 1. Механика работы

### Очередь LIFO (Last-In-First-Out)
Отложенные функции вызываются в порядке, обратном их объявлению. Это напоминает стек: последняя добавленная функция будет выполнена первой. Это крайне удобно для поэтапной очистки ресурсов.

```go
func main() {
    defer fmt.Println("Первый")
    defer fmt.Println("Второй")
    defer fmt.Println("Третий")
    // Вывод: Третий, Второй, Первый
}
```

### Вычисление аргументов
Аргументы функции `defer` вычисляются **в момент объявления**, а не в момент выполнения.

```go
func main() {
    i := 0
    defer fmt.Println(i) // i будет 0, так как значение копируется здесь
    i++
    return
}
```

---

## 2. Defer и именованные возвращаемые значения

`defer` может изменять именованные возвращаемые значения функции. Это происходит потому, что `defer` выполняется **после** того, как инструкция `return` установила значения, но **до** фактического выхода из функции.

```go
func result() (x int) {
    defer func() {
        x++ // Изменяем возвращаемое значение
    }()
    return 5 // x становится 5, затем defer делает x = 6
}
```

---

## 3. Panic и Recover

`defer` часто используется вместе с `recover()` для перехвата паники и предотвращения падения всей программы.

```go
func safeFunction() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Восстановлено после паники:", r)
        }
    }()
    panic("что-то пошло не так")
}
```

### Важные ограничения Panic/Recover:
1. **Scope (Область видимости)**: Вы не можете поймать панику из другой горутины. Каждая горутина должна иметь свой `defer/recover`.
2. **Типы ошибок, которые НЕЛЬЗЯ поймать**:
    - **Out of Memory (OOM)**: Если системе не хватает памяти, рантайм Go просто завершает процесс. `recover` здесь не поможет.
    - **Stack Overflow**: Переполнение стека также нельзя обработать через `defer`.
    - **Fatal errors** в рантайме (например, повреждение памяти).

### Что МОЖНО поймать:
- **Runtime panics**: деление на ноль, разыменование nil-указателя, выход за границы слайса. Эти ошибки инициируют стандартный механизм паники, который `defer` может перехватить.

---

## 4. Зачем использовать defer?

1. **Очистка ресурсов**: Закрытие файлов (`f.Close()`), сетевых соединений или дескрипторов.
2. **Разблокировка мьютексов**: `defer mu.Unlock()` гарантирует, что мьютекс будет освобожден даже при возникновении паники.
3. **Логирование**: Замер времени выполнения функции или логирование результата выхода.
4. **Снятие Panic**: Предотвращение падения сервиса при возникновении непредвиденных ошибок.

---

## 5. Под капотом и производительность

- **Стек**: Объекты `defer` хранятся в связанном списке внутри структуры горутины (`g`). Это требует аллокации в куче (хотя в новых версиях Go (1.13+) появились оптимизации "open-coded defers", которые делают вызовы почти бесплатными для простых случаев).
- **Аргументы**: Все аргументы копируются в момент вызова `defer`. Это важно помнить при работе с большими структурами (лучше передавать указатели).

> [!IMPORTANT]
> Не используйте `defer` внутри циклов с большим количеством итераций, если это не обосновано. Все отложенные вызовы будут копиться до выхода из функции, что может привести к временному всплеску потребления памяти.

---

## Итог для интервью

| Ошибка | Можно поймать через defer/recover? |
| :--- | :--- |
| Деление на 0 | ✅ Да |
| Nil pointer dereference | ✅ Да |
| Index out of range | ✅ Да |
| Stack Overflow | ❌ Нет |
| Out of Memory (OOM) | ❌ Нет |
| Паника в другой горутине | ❌ Нет |
