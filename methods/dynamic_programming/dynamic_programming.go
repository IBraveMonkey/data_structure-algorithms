package dynamic_programming

/*Dynamic Programming (Динамическое программирование)

Что это такое?
	Представь, что ты считаешь, сколько способов подняться по лестнице на 10 ступенек, если можешь шагать на 1 или 2 ступеньки за раз. Ты можешь посчитать всё заново для каждой ступеньки, но это долго. Вместо этого ты запоминаешь результаты для маленьких кусочков (например, 1 ступенька, 2 ступеньки) и используешь их для больших. Это и есть динамическое программирование — решаем задачу, разбивая её на подзадачи и сохраняя их решения, чтобы не считать заново.

	Зачем это нужно?
	-Ускорить решение задач, где много повторяющихся вычислений.
	-Найти оптимальный ответ (максимум, минимум) или посчитать количество вариантов.

	В чём смысл?
	-Разделяем задачу на маленькие шаги.
	-Сохраняем ответы для этих шагов (в массиве или таблице).
	-Используем их, чтобы не повторять одну и ту же работу.

	Когда использовать?

Есть повторяющиеся подзадачи (например, числа Фибоначчи).
Нужно найти оптимум (максимум, минимум) или количество способов.
Задача имеет рекуррентную формулу (можно выразить решение через предыдущие).

	Как работает?
	-Определяем, на какие подзадачи разбить.
	-Создаём массив (или таблицу), чтобы хранить решения подзадач.
	-Заполняем его шаг за шагом, используя прошлые результаты.
	-Итоговый ответ — в последней ячейке (или где-то ещё, зависит от задачи).

	Пример из жизни
	Ты хочешь дойти до школы кратчайшим путём. Вместо того чтобы каждый раз проверять все дороги от дома, ты запоминаешь кратчайший путь до каждого перекрёстка и используешь это, чтобы найти общий маршрут.

	Как понять, что задача подходит под Dynamic Programming?
	-Есть повторяющиеся вычисления (как в Фибоначчи).
	-Можно выразить решение через меньшие подзадачи.
	-Нужно найти оптимум или количество.
*/

/*Задача 1: Числа Фибоначчи

Условие: Найти n-е число Фибоначчи (F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)).

Пример:
Ввод: n = 6
Вывод: 8 (0, 1, 1, 2, 3, 5, 8)
*/

func Fib(n int) int {
	if n <= 0 {
		return 0
	}

	if n == 1 {
		return 1
	}

	dp := make([]int, n+1) // Массив для хранения чисел Фибоначии
	dp[0] = 0              // F(0)
	dp[1] = 1              // F(1)

	for i := 2; i <= n; i++ { // Заполняем массив шаг за шагом
		dp[i] = dp[i-1] + dp[i-2] // F(n) = F(n-1) + F(n-2)
	}

	return dp[n] // Ответ - последнее число
}

/*
Задача 2: Задача о рюкзаке (0/1 Knapsack)

Условие: Даны веса предметов, их стоимости и максимальный вес рюкзака. Найти максимальную стоимость, которую можно унести.

Пример:
Ввод: weights = [1, 3, 4, 5], values = [1, 4, 5, 7], capacity = 7
Вывод: 9 (берём предметы с весом 3 и 4, стоимость 4 + 5 = 9)
*/
func Knapsack(weights, values []int, capacity int) int {
	n := len(weights)
	dp := make([][]int, n+1) // Таблица: строки — предметы, столбцы — вес

	// [[], [], [], []]
	for i := range dp {
		dp[i] = make([]int, capacity+1)
	}

	for i := 1; i <= n; i++ { // Проходим по предметам
		for w := 0; w <= capacity; w++ { // Проходим по весу
			if weights[i-1] <= w { // Если предмет помещается
				dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]]+values[i-1])
			} else { // Если не помещается, берём без него
				dp[i][w] = dp[i-1][w]
			}
		}
	}
	return dp[n][capacity] // Ответ в последней ячейке
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

/*
Задача 3: Самая длинная общая подпоследовательность (LCS)

Условие: Даны две строки, найти длину самой длинной общей подпоследовательности.

Пример:

Ввод: s1 = "AGGTAB", s2 = "GXTXAYB"

Вывод: 4 (подпоследовательность "GTAB")
*/

func LongestCommonSubsequence(s1, s2 string) int {
	m, n := len(s1), len(s2)
	dp := make([][]int, m+1) // Таблица: строки — символы s1, столбцы — s2
	for i := range dp {
		dp[i] = make([]int, n+1)
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s1[i-1] == s2[j-1] { // Если символы совпадают
				dp[i][j] = dp[i-1][j-1] + 1
			} else { // Если нет, берём максимум без одного из символов
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}
	return dp[m][n] // Ответ в последней ячейке
}
