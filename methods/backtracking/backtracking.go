package backtracking

/*
	Backtracking (Обратный ход)
	Что это такое?
	Представь, что ты идёшь по лабиринту. Ты выбираешь путь, идёшь по нему, но если упираешься в тупик, возвращаешься назад и пробуешь другой путь. Это и есть обратный ход — метод, где ты строишь решение шаг за шагом, а если что-то не работает, отменяешь последний шаг и пробуешь заново.

	Зачем это нужно?
	-Найти все возможные решения (например, все комбинации чисел).
	-Решить задачи, где нужно перебрать варианты, но не все сразу, а постепенно.

	В чём смысл?
	Ты идёшь вперёд, пока можешь, а если ошибся — возвращаешься и пробуешь другой вариант.
	Это как собирать пазл: кладешь кусочек, если не подходит — убираешь и берёшь другой.

	Когда использовать?
	-Задачи на комбинации, перестановки, разбиения (например, все способы разложить число).
	-Паззлы или головоломки (судоку, шахматные задачи).
	-Когда нужно проверить все варианты, но перебор всех сразу слишком долгий.

	Как работает?
	1)Начинаешь с пустого решения.
	2)Добавляешь шаг (например, число или букву).
	3)Проверяешь, подходит ли это:
	4)Если да — идёшь дальше.
	5)Если нет — убираешь шаг и пробуешь другой.
	6)Повторяешь, пока не найдёшь решение или не перепробуешь всё.

*/

/*	Задача 1: Найти все перестановки строки
Условие: Дана строка, найти все возможные перестановки её символов.

Пример:
Ввод: s = "abc"
Вывод: ["abc", "acb", "bac", "bca", "cab", "cba"]
*/

func Permute(s string) []string {
	result := []string{}                    // Тут будем хранить все перестановки
	used := make([]bool, len(s))            // Отмечаем, какие буквы уже взяли
	backtrack([]byte(s), used, "", &result) // Запускаем процесс
	return result
}

func backtrack(chars []byte, used []bool, current string, result *[]string) {
	if len(current) == len(chars) { // Если собрали строку нужной длины
		*result = append(*result, current) // Добавляем в список
		return
	}

	for i := 0; i < len(chars); i++ { // Пробуем каждую букву
		if !used[i] { // Если буква ещё не использована
			used[i] = true                                           // Отмечаем, что взяли её
			backtrack(chars, used, current+string(chars[i]), result) // Добавляем и идём дальше
			used[i] = false                                          // Отменяем выбор (возвращаемся)
		}
	}
}

func Partition(n int) [][]int {
	result := [][]int{}                        // Все разбиения
	backtrackPartition(n, n, []int{}, &result) // Запускаем обратный ход
	return result
}

func backtrackPartition(n, maxAllowed int, current []int, result *[][]int) {
	if n == 0 { // Если набрали нужную сумму
		temp := make([]int, len(current))
		copy(temp, current)
		*result = append(*result, temp) // Добавляем разбиение
		return
	}

	for i := 1; i <= maxAllowed && i <= n; i++ { // Пробуем числа от 1 до maxAllowed
		current = append(current, i)                // Добавляем число
		backtrackPartition(n-i, i, current, result) // Идём дальше с остатком
		current = current[:len(current)-1]          // Убираем число (возврат)
	}
}
