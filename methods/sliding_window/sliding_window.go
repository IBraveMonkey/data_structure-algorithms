package sliding_window

/*
	Sliding Window(Скользящее окно)
	Представь, что у тебя есть линейка с числами, и ты двигаешь по ней окошко (фиксированного или переменного размера), чтобы найти, например, сумму чисел в этом окошке или самую длинную последовательность букв. Это и есть скользящее окно — подмассив, который ты сдвигаешь по данным, добавляя элементы справа и убирая слева.

	Зачем это нужно?
	- Быстро решать задачи про подмассивы или подстроки (O(n) вместо O(n²)).
	- Искать максимумы, минимумы или определённые свойства в "окне" данных.

	В чём смысл?
	- Не пересчитывать всё заново для каждого подмассива, а обновлять результат при сдвиге окна.
	- Экономить время, работая только с нужным куском данных.

	Когда использовать?
	-Задачи про подмассивы или подстроки с условиями (сумма, длина, уникальность).
	-Нужно найти максимум/минимум чего-то в непрерывном диапазоне.
	-Данные линейные (массив, строка), и подмножества должны быть последовательными.

	Как работает?
	1) Определяешь размер окна (фиксированный или переменный).
	2) Начинаешь с левого края, двигаешь правый край, пока окно не "заполнится".
	3) Когда окно готово, считаешь результат (сумму, количество символов и т.д.).
	4)Сдвигаешь окно: убираешь слева, добавляешь справа, обновляешь результат.
	5) Повторяешь, пока не пройдёшь все данные.
*/

/* Задача 1 Найти масимальную сумму подмассива фиксированной длины K
Условие: Дан массив чисел и число к. Найди масимальную сумму подмассива длиной к.

Ввод - arr[1,4,2,10,2,3,1], k =3
Вывод: 16 (подмассив [4,2,10])
*/

func MaxSumSubarray(arr []int, k int) int {
	if len(arr) == 0 {
		return 0
	}

	// Считаем сумму первого окна (первые к элементов)
	windowSum := 0
	for i := 0; i < k; i++ {
		windowSum += arr[i] // Складываем: 1 + 4 + 2 =7
	}
	maxSum := windowSum // Инициализируем максимум // 7

	// Сдвигаем окно по массиву
	for i := k; i < len(arr); i++ { // i - это первый край окна
		// i=3: 7 + 10 - 1 = 16
		// i=4: 16 + 2 - 4 = 14
		// i=5: 14 + 3 - 2 = 15
		// i=6: 15 + 1 - 10 = 6
		windowSum = windowSum + arr[i] - arr[i-k] // Добавляем новый элемент, убираем старый

		if windowSum > maxSum {
			maxSum = windowSum // Обновляем максимум
		}
	}

	return maxSum
}

/* Задача 2 Найти длину самой длинной подстроки без повторящихся символов
Условие: Дана строка, найди длину самой длинной подстроки, где все символы уникальны

Пример:
Ввод: s="abcabcbb"
Вывод: 3 (подстровка "abc")
*/

func LengthOfLongestSubstring(s string) int {
	if len(s) == 0 {
		return 0
	}

	charMap := make(map[byte]int) // Карта: какая буква где была последний раз
	maxLength := 0                // Самая большая длина без повторов
	left := 0                     // Левый край окна

	for right := 0; right < len(s); right++ { // Правый край окна идет вперед
		// Проверяем, есть ои текущая буква в окне
		if pos, exists := charMap[s[right]]; exists && pos >= left {
			left = pos + 1 // Если есть повтор, сдвигаем левый край за строе место буквы
		} else {
			// Если нет повторов, считаем длину окна
			currentLength := right - left + 1
			if currentLength > maxLength {
				maxLength = currentLength // Обновляем максимум
			}
		}
		charMap[s[right]] = right // Записываем, где теперь эта буква
	}

	return maxLength
}

/*Задача: Минимальная длина подмассива с суммой ≥ target

Условие: Дан массив положительных чисел и число target. Найти длину самого короткого подмассива, у которого сумма элементов не меньше target. Если такого нет, вернуть 0.

Пример:
Ввод: arr = [2, 3, 1, 2, 4, 3], target = 7
Вывод: 2 (потому что самый короткий подмассив с суммой ≥ 7 — это [4, 3], сумма = 4 + 3 = 7, длина = 2).
*/

func MinSubArrayLen(target int, arr []int) int {
	if len(arr) == 0 {
		return 0
	}

	minLength := len(arr) + 1 // Самая короткая длина, изначально больше массива
	windowSum := 0            // Сумма чисел в окна
	left := 0                 // Левый край окна

	for right := 0; right < len(arr); right++ { // Правый край идет вперед
		windowSum += arr[right] // Добавляем новое число в окно

		// пока сумма ≥ target, сжимаем окно слева
		for windowSum >= target {
			currentLength := right - left + 1 // Считаем длину окна
			if currentLength < minLength {    // Если короче, чем было
				minLength = currentLength // Запоминаем
			}
			windowSum -= arr[left] // Убираем число слева
			left++                 // Сдвигаем левый край
		}
	}

	if minLength > len(arr) { // Если не нашли подходящего окна
		return 0
	}

	return minLength // Возвращаем самую длинное окно
}
