package quick_sort

/*
	Быстрая сортировка (QuickSort) — это высокоэффективный алгоритм сортировки, основанный на
	принципе "разделяй и властвуй". Он выбирает опорный элемент (pivot), разделяет массив на
	две части относительно этого элемента, а затем рекурсивно сортирует получившиеся подмассивы.

Алгоритм:
	1) Выбираем опорный элемент (pivot). В данной реализации используется метод "медианы трёх"
	   (median of three), чтобы выбрать более сбалансированный pivot и избежать худшего случая.
	2) Разделяем массив на две части:
	   - Элементы, меньшие или равные pivot, помещаются в левую часть (left).
	   - Элементы, большие pivot, помещаются в правую часть (right).
	3) Рекурсивно применяем QuickSort к левой и правой частям.
	4) Объединяем отсортированные части с pivot в итоговый массив: [sortedLeft, pivot, sortedRight].

Характеристики алгоритма:
- Устойчивость: Нет, алгоритм неустойчив, так как при разделении и обмене элементов
  относительный порядок равных элементов может измениться.
  - Временная сложность:
	  - Лучший случай: O(n log n) — когда pivot делит массив примерно пополам на каждой итерации,
	    глубина рекурсии составляет log n, а на каждом уровне выполняется O(n) сравнений.
	  - Средний случай: O(n log n) — при случайном выборе pivot массив обычно делится достаточно
	    равномерно, что сохраняет логарифмическую глубину рекурсии.
	  - Худший случай: O(n²) — возникает, если pivot постоянно оказывается крайним элементом
	    (например, минимальным или максимальным), что приводит к неравномерному разделению
	    (одна часть пустая, другая почти весь массив). Это может случиться, если массив уже
	    отсортирован или состоит из одинаковых элементов, а pivot выбирается неудачно.
	  - Подробно:
	    * При O(n log n) на каждом уровне рекурсии выполняется n сравнений, а уровней — log n.
	    * При O(n²) глубина рекурсии становится n, и на каждом уровне выполняется до n операций.
 	- Пространственная сложность:
	  - В данной реализации: O(n) в среднем и O(n) в худшем случае из-за создания новых массивов
	    (left и right) для хранения элементов. Это не "in-place" реализация.
	  - В классической "in-place" версии: O(log n) в среднем для стека вызовов рекурсии, так как
	    глубина рекурсии логарифмическая; O(n) в худшем случае, если рекурсия несбалансирована.
	  - Примечание: использование append() и создание новых массивов увеличивает потребление
	    памяти по сравнению с "in-place" версией, где элементы переставляются в исходном массиве.
	- Преимущества:
	  - Высокая производительность в среднем случае (O(n log n)).
	  - Эффективен для больших массивов при хорошем выборе pivot.
	- Недостатки:
	  - Зависимость от выбора pivot: неудачный выбор может привести к O(n²).
	  - Данная реализация не является "in-place", что увеличивает использование памяти.
*/

func medianOfThree(arr []int, low, hight int) int {
	mid := low + (hight-low)/2

	// Сравнение трех элементов: первый, средний, последний
	if arr[low] > arr[mid] {
		arr[low], arr[mid] = arr[mid], arr[low]
	}

	if arr[low] > arr[hight] {
		arr[low], arr[hight] = arr[hight], arr[low]
	}

	if arr[mid] > arr[hight] {
		arr[mid], arr[hight] = arr[hight], arr[mid]
	}

	// Медиана теперь в arr[mid], возвращаем индекс
	return mid
}

// В это случае будет O(n log n)
func QuickSort(arr []int) []int {
	// Базовый случай, если длина массива <= 1 он уже отсортирован
	if len(arr) <= 1 {
		return arr
	}

	// Выбираем опорный элемент (pivot)
	pivotIndex := medianOfThree(arr, 0, len(arr)-1)
	pivot := arr[pivotIndex]
	left := []int{}
	right := []int{}

	// разделяем массив на элементы меньше или больше pivot
	for i := 0; i < len(arr); i++ {
		if i == pivotIndex {
			continue
		}

		if arr[i] <= pivot {
			left = append(left, arr[i])
		} else {
			right = append(right, arr[i])
		}
	}

	sortedLeft := QuickSort(left)   // сортируем левую часть
	sortedRight := QuickSort(right) // сортируем правую часть

	// Складываем результат, левый массив + pivot + правый массив
	result := append(sortedLeft, pivot)
	result = append(result, sortedRight...)

	return result
	// Рекурсивно сортируем левую и правую части и объединяем pivot
	// return append(append(QuickSort(left), pivot), QuickSort(right)...)
}
