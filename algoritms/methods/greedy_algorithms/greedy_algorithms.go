package greedy_algorithms

import "sort"

/*
Greedy Algorithms (Жадные алгоритмы)

	Что это такое?
	Представь, что ты в магазине с ограниченными деньгами и хочешь купить как можно больше вкусняшек. Ты берёшь сначала самое дешёвое, потом следующее по цене, и так далее, пока деньги не кончатся. Это и есть жадный алгоритм — на каждом шаге ты делаешь лучший выбор прямо сейчас, надеясь, что в итоге получится хороший результат.

	Зачем это нужно?
	-Быстро решать задачи, где не нужно перебирать все варианты.
	-Найти приближённое или точное решение, если локальный выбор ведёт к глобальному.

	В чём смысл?
	Делаешь самый очевидный "лучший" шаг на данный момент.
	Не оглядываешься назад и не пересчитываешь другие варианты.
	Работает только если локальная жадность приводит к правильному ответу.

	Когда использовать?
	-Задачи на минимизацию или максимизацию (например, минимальное количество монет, максимальная выгода).
	-Условие позволяет двигаться "пошагово" без возврата.
	-Есть чёткое правило, что выбрать на каждом шаге (самое большое, самое маленькое и т.д.).

	Как работает?
	-Определяешь, что значит "лучший выбор" на каждом шаге.
	-Делаешь этот выбор и идёшь дальше.
	-Повторяешь, пока не решишь задачу.

	Пример из жизни
	Ты собираешь рюкзак для похода и берёшь вещи с максимальной полезностью на единицу веса, пока рюкзак не заполнится.

	Ограничение
	Жадные алгоритмы не всегда дают правильный ответ — нужно проверять, подходит ли задача.


	Как понять, что задача подходит под Greedy?
	-Есть чёткий "лучший" выбор на каждом шаге (самое большое, самое маленькое).
	-Локальная оптимальность ведёт к глобальной (нужно проверять!).
	-Не нужно возвращаться и пересматривать решения.
*/

/*Задача 1: Минимальное количество монет для сдачи
Условие: Дан массив номиналов монет и сумма. Найти минимальное количество монет для набора этой суммы.

Пример:
Ввод: coins = [1, 2, 5], amount = 11
Вывод: 3 (5 + 5 + 1 = 11)
*/
// Смысл: Берём монету максимального номинала, пока можем, затем уменьшаем номинал.
// Примечание: Этот жадный подход работает только для некоторых наборов монет (например, [1, 2, 5]). Для других (например, [1, 4, 6] и сумма 8) он может ошибаться — это ограничение жадности.

func CoinChange(coins []int, amount int) int {
	count := 0          // Количество монет
	remaining := amount // Остаток суммы

	// Сортируем монеты по убыванию (если не отсортированы)
	for i := len(coins) - 1; i >= 0; i-- {
		for remaining >= coins[i] { // Пока можем брать эту монету
			remaining -= coins[i] // Вычитаем номинал
			count++               // Увеличиваем счётчик
		}
	}

	if remaining != 0 { // Если остался остаток, сумма невозможна
		return -1
	}

	return count
}

/*
Задача 2: Выбор непересекающихся интервалов

Условие: Дан список интервалов (начало, конец). Найти максимальное количество непересекающихся интервалов.

Пример:
Ввод: intervals = [[1,2], [2,3], [3,4], [1,3]]
Вывод: 3 (можно взять [1,2], [2,3], [3,4])
*/
func MaxNonOverlapping(intervals [][]int) int {
	// Сортируем по концу интервала
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][1] < intervals[j][1]
	})

	count := 1                 // Первый интервал всегда берём
	lastEnd := intervals[0][1] // Конец последнего выбранного интервала

	for i := 1; i < len(intervals); i++ {
		if intervals[i][0] >= lastEnd { // Если начало текущего после конца последнего
			count++                   // Берём интервал
			lastEnd = intervals[i][1] // Обновляем конец
		}
	}
	return count
}
