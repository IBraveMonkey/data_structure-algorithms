package merge_sort

/*
Merge Sort (Сортировка слиянием)

Что это такое?
Merge Sort — это алгоритм сортировки, основанный на принципе "Разделяй и властвуй". Он рекурсивно делит массив пополам, пока не останутся кусочки длиной 1 (они уже отсортированы), а затем "сливает" (merge) эти кусочки обратно в правильном порядке.

Зачем это нужно?
- Гарантированное время работы O(n log n) даже в худшем случае (в отличие от Quick Sort).
- Устойчивая сортировка (сохраняет порядок равных элементов).
- Хорошо подходит для сортировки связанных списков или данных, которые не помещаются в память (External Sorting).

В чём смысл?
- Слить два отсортированных массива в один очень просто и быстро (за O(n)).
- Вся сложность алгоритма сводится к этому слиянию.

Когда использовать?
- Когда нужна гарантированная производительность O(n log n).
- Когда важна устойчивость (stable).
- При работе с Linked List (так как не требует random access).

Как работает?
1. Если массив длины 0 или 1 — возвращаем его.
2. Делим массив на Left и Right посередине.
3. Рекурсивно вызываем MergeSort(Left) и MergeSort(Right).
4. Сливаем результаты функцией Merge.

### Сложность

| Метрика | Сложность (O) |
|:---|:---:|
| Время (всегда) | O(n log n) |
| Память | O(n) |
| Устойчивость | ✅ (Устойчив) |

\*O(n) памяти требуется для временного буфера при слиянии.
*/

func merge(left, right []int) []int {
	result := make([]int, 0, len(left)+len(right))
	i, j := 0, 0

	for i < len(left) && j < len(right) {
		if left[i] <= right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}

	result = append(result, left[i:]...)
	result = append(result, right[j:]...)

	return result
}

func MergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}

	mid := len(arr) / 2
	left := MergeSort(arr[:mid])
	right := MergeSort(arr[mid:])

	return merge(left, right)
}
